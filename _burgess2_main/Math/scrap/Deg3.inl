
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T () 
	: x { 0 }
	, y { 0 }
	, z { 0 } 
	, rotationOrder { 0 }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( T val )
	: x { val }
	, y { val }
	, z { val }
	, rotationOrder { 0 } {}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( T setX, T setY, T setZ, u8 order ) 
	: x { setX }
	, y { setY }
	, z { setZ } 
	, rotationOrder { order }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const VecT<T> &vec, u8 order ) {
	assert ( 3 <= vec.size () );
	*this = { vec [0], vec [1], vec [2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const Vec3T<T> &vec, u8 order ){
	*this = { vec[0], vec[1], vec[2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const Vec4T<T> &vec, u8 order ){
	*this = QuatT<T>( vec ).toDeg3 ( order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const Rad3T<T> &rad ) {
	*this = rad.toDeg3 ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const Mat3T<T> &m3, u8 order ) {
	this->setFromMat3 ( m3, order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const Mat4T<T> &m4, u8 order ) {
	Mat3T<T> m3 = m4.getMat3 ();
	*this = Deg3T<T> (m3, order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const QuatT<T> &quat, u8 order ) {
	*this = quat.toDeg3 ( order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T>::Deg3T ( const std::vector<T> &arrayVal, u8 order ) {
	assert ( 3 <= arrayVal.size () );
	*this = { arrayVal [0], arrayVal [1], arrayVal [2], order };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Deg3T<T>::toVec ()const {
	return VecT<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Deg3T<T>::toTypeArray () const {
	return std::vector<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rad3型へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T> Deg3T<T>::toRad3 () const {
	return Rad3T<T> { Math::DegToRad ( this->x ), Math::DegToRad ( this->y ), Math::DegToRad ( this->z ), this->rotationOrder };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Quat型へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> Deg3T<T>::toQuat () const {
	return QuatT<T> {*this};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3型へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Deg3T<T>::toMat3 () const {
	return QuatT<T> ( *this ).toMat3 ();
}


//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Deg3T<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	String order = std::to_string ( this->rotationOrder );
	switch ( this->rotationOrder ) {
	case 0:
		order += "[XYZ]";
		break;
	case 1:
		order += "[XZY]";
		break;
	case 2:
		order += "[YXZ]";
		break;
	case 3:
		order += "[YZX]";
		break;
	case 4:
		order += "[ZYX]";
		break;
	case 5:
		order += "[ZXY]";
		break;
	default:
		order += "[XYZ]";
	}
	return t + "Deg3:[" + GetFloorString ( this->x ) + ", " + GetFloorString ( this->y ) + ", " + GetFloorString ( this->z ) + ", rotationOrder : " + order + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3からDeg3を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Deg3T<T>::setFromMat3 ( const Mat3T<T> &mat3, u8 order ) {
	Rad3T<T> rad ( mat3, order );
	*this = Deg3T<T> ( rad );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのラジアン単位オイラーの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Deg3T<T>::equal ( const Deg3T &other ) const {
	return this->x == other.x && this->y == other.y && this->z == other.z && this->rotationOrder == other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのラジアン単位オイラーの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Deg3T<T>::almostEqual ( const Deg3T &other, T tolerance ) const {
	return
		( std::abs ( this->x - other.x ) < tolerance ) &&
		( std::abs ( this->y - other.y ) < tolerance ) &&
		( std::abs ( this->z - other.z ) < tolerance ) && 
		this->rotationOrder == other.rotationOrder ;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     自身の回転値を適応したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Deg3T<T>::rotatVector ( const Vec3T<T> &vec3 ) const{
	QuatT<T> quat { *this };
	return quat.rotatVector ( vec3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x,y,zへ[0~2]としてアクセスする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Deg3T<T>::operator[]( u8 id ) {
	assert ( id < 3 );
	switch ( id ) {
	case 0:
		return this->x;
		break;
	case 1:
		return this->y;
		break;
	case 2:
		return this->z;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Deg3T<T>::operator[]( u8 id ) const {
	assert ( id < 3 );
	switch ( id ) {
	case 0:
		return this->x;
		break;
	case 1:
		return this->y;
		break;
	case 2:
		return this->z;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Deg3T<T>::operator == ( const Deg3T &other ) const {
	return this->x == other.x && this->y == other.y && this->z == other.z && this->rotationOrder == other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Deg3T<T>::operator != ( const Deg3T &other ) const {
	return this->x != other.x || this->y != other.y || this->z != other.z || this->rotationOrder != other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T> Deg3T<T>::operator + ( const Deg3T &other )const {
	assert ( this->rotationOrder == other.rotationOrder );
	return Deg3T<T> { this->x + other.x, this->y + other.y, this->z + other.z, this->rotationOrder };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Deg3T<T>::operator += ( const Deg3T &other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T> Deg3T<T>::operator - ( const Deg3T &other ) const {
	assert ( this->rotationOrder == other.rotationOrder );
	return Deg3T<T> { this->x - other.x, this->y - other.y, this->z - other.z, this->rotationOrder };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Deg3T<T>::operator -= ( const Deg3T &other ) {
	*this = *this - other;
}