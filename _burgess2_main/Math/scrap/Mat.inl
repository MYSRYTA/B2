
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT () 
	: rows { 0 }
	, cols { 0 }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( u32 n ) {
	*this = MatT<T>();
	this->initialize ( n, n );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( u32 rowSize, u32 colSize ) {
	*this = MatT<T>();
	this->initialize ( rowSize, colSize );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( const std::vector<Vec3T<T>> &vecArray ){
	if ( vecArray.size () == 0 ){
		*this = MatT<T> ();
		return;
	}

	this->reset ( vecArray.size (), 3 );
	#pragma omp parallel for
	for ( s32 i = 0, n = vecArray.size (); i < n; ++i ){
		for ( u32 col = 0; col < 3; ++col ){
			this->setValue ( i * 3 + col, vecArray[i][col] );
		}
	}
};

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( const std::vector<Vec4T<T>> &vecArray ){
	if ( vecArray.size () == 0 ){
		*this = MatT<T> ();
		return;
	}

	this->reset ( vecArray.size (), 4 );
	#pragma omp parallel for
	for ( s32 i = 0, n = vecArray.size (); i < n; ++i ){
		for ( u32 col = 0; col < 4; ++col ){
			this->setValue ( i * 4 + col, vecArray[i][col] );
		}
	}
};

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( const std::vector<VecT<T>> &vecArray ) {
	u32 rows = u32(vecArray.size ());
	u32 cols = 0 < rows ? vecArray [0].size () : 0;
	if ( rows == 0 || cols == 0 ) {
		*this = MatT<T>();
		return;
	}

	this->reset ( rows, cols );
	#pragma omp parallel for
		for ( int i = 0; i < int(rows); i++ ) {
			for ( u32 col = 0; col<cols; ++col ) {
				this->setValue ( i * cols + col, vecArray [i].get ( col ) );
			}
		}
};

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT ( const MatT &other ) {
	this->rows = other.getRowCount();
	this->cols = other.getColCount();
	this->values = other.values;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     初期化(全ての値は0.0)する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::initialize ( u32 rowSize, u32 colSize ) {
	this->rows = rowSize;
	this->cols = colSize;
	this->values.resize ( rowSize * colSize );
	this->setAllValues ( T(0.0) );
}



//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     正方形の単位マトリックス(対角線の値が1.0)にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setIdentity ( u32 size ) {
	this->setDiagonal ( size, T(1.0) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全て同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setAllValues ( T val ) {
	for (u32 i = 0; i < this->values.size (); ++i) {
		this->values[i] = val;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定した座標に値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setValue ( u32 rowIndex, u32 colIndex, T val ) {
	assert ( rowIndex < this->getRowCount() && colIndex < this->getColCount() );
	this->setValue ( (this->getColCount() * rowIndex) + colIndex, val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setValue ( u32 index, T val ) {
	assert ( index < this->values.size () );
	this->values[index] = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      指定したRowの値をVecにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setRowValues ( u32 row, const VecT<T> &vec ) {
	u32 size = this->getColCount () < vec.size () ? this->getColCount() : vec.size ();
	for (u32 i = 0; i < size; i++) {
		this->setValue ( row, i, vec.get ( i ) );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定したRowの値を全てvalにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setRowAllValues ( u32 row, T val ) {
	for ( u32 i = 0; i < this->getColCount(); i++ ) {
		this->setValue ( row, i, val );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定したColの値をVecにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setColValues (u32 colIndex, const VecT<T> &vec) {
	u32 size = this->getRowCount() < vec.size () ? this->getRowCount() : vec.size ();
	for (u32 i = 0; i < size; i++) {
		this->setValue ( i, colIndex, vec.get ( i ) );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定したColの値を全てvalにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setColAllValues (u32 colIndex, T val) {
	for (u32 i = 0; i < this->getRowCount(); i++) {
		this->setValue ( i, colIndex, val );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     resizeの正方形マトリックスにリサイズして対角要素を全てValにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setDiagonal ( u32 resize, T val ) {
	this->rows = resize;
	this->cols = resize;
	this->values.resize ( resize * resize );
	for (u32 row = 0; row < resize; ++row) {
		for (u32 col = 0; col < resize; ++col) {
			if (row == col) {
				this->values[row * resize + col] = val;
			} else {
				this->values [row * resize + col] = 0;
			}
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecの要素数の正方形マトリックスにリサイズして対角要素をVecの値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setDiagonal ( const VecT<T> &vec ) {
	u32 size = u32 ( vec.size () );
	this->rows = size;
	this->cols = size;
	this->values.resize ( size * size );
	for (u32 row = 0; row < size; ++row) {
		for (u32 col = 0; col < size; ++col) {
			if(row == col) {
				this->values[row * size + col] = vec.get ( row );
			} else {
				this->values [row * size + col] = 0;
			}
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     リサイズして全ての値を0にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::reset ( u32 rowSize, u32 colSize ) {
	this->initialize ( rowSize, colSize );
	this->setAllValues ( T ( 0.0 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rowの数を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
u32 MatT<T>::getRowCount () const {
	return this->rows;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Colの数を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
u32 MatT<T>::getColCount () const {
	return this->cols;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T MatT<T>::get ( u32 index ) const {
	return this->values[index];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定した座標の値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T MatT<T>::get ( u32 rowIndex, u32 colIndex ) const {
	return this->get ( this->getColCount() * rowIndex + colIndex );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rowの値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getRowValues ( u32 rowIndex ) const {
	VecT<T> result ( this->getColCount () );
	for (u32 i = 0; i < this->getColCount(); i++) {
		result.set ( i, this->get ( rowIndex, i ) );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Colの値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getColValues ( u32 colIndex ) const {
	VecT<T> result ( this->getRowCount () );
	for (u32 i = 0; i < this->getRowCount(); i++) {
		result.set ( i, this->get ( i, colIndex ) );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     各Rowの最小値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getRowsMinValues () const {
	VecT<T> result ( this->getRowCount () );
	for (u32 i = 0; i < this->getRowCount(); i++) {
		VecT<T> vec = this->getRowValues ( i );
		result.set ( i, vec.minimum () );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     各Rowの最大値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getRowsMaxValues () const {
	VecT<T> result ( this->getRowCount () );
	for (u32 i = 0; i < this->getRowCount(); i++) {
		VecT<T> vec = this->getRowValues ( i );
		result.set ( i, vec.maximum () );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     各Colの最小値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getColsMinValue () const {
	VecT<T> result ( this->getColCount () );
	for (u32 i = 0; i < this->getColCount(); i++) {
		VecT<T> vec = this->getColValues ( i );
		result.set ( i, vec.minimum () );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     各Colの最大値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getColsMaxValue () const {
	VecT<T> result ( this->getColCount () );
	for (u32 i = 0; i < this->getColCount(); i++) {
		VecT<T> vec = this->getColValues ( i );
		result.set ( i, vec.maximum () );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String MatT<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	String s = "values[";
	for ( u32 i = 0; i<this->values.size () -1; i++ ) {
		s += GetFloorString ( this->values [i] ) + ", ";
	}
	s += GetFloorString ( this->values [this->values.size ()-1] ) + "]";
	return t + "Mat:[rowSize=" + GetFloorString(this->rows) + " / colSize=" + GetFloorString(this->cols) + " / " + s + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::equal ( const MatT<T> &other ) const {
	assert ( this->getColCount () == other.getColCount () && this->getRowCount () == other.getRowCount () );
	for (u32 i = 0; i < this->values.size (); ++i) {
		if (this->values[i] != other.values[i]) {
			return false;
		}
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::almostEqual ( const MatT<T> &other, T tolerance ) const {
	assert ( this->getColCount () == other.getColCount () && this->getRowCount () == other.getRowCount () );
	for (u32 i = 0; i < this->values.size (); ++i) {
		if ( tolerance <= std::abs ( this->values[i] - other.values [i] )) {
			return false;
		}
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     RowとColが同数の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::isSquare () const {
	return this->rows == this->cols;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      t値(0.0~1.0)に基づいて対象マトリックスと線形補間したマトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::lerp ( const MatT<T> &other, T t ) const {
	return *this * (1.0f - t) + other * t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象マトリックスと線形補間したマトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::linearInterpolate ( const MatT<T> &other, T t ) const {
	return this->lerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rowを入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::swapRows ( u32 row1, u32 row2 ) {
	for (u32 i = 0; i < this->getColCount(); i++) {
		std::swap(this->values[row1 * this->getColCount() + i], this->values[this->getColCount() * row2 + i]);
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Colを入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::swapCols ( u32 col1, u32 col2 ) {
	for (u32 i = 0; i < this->getRowCount(); i++) {
		std::swap(this->values[this->getColCount() * i + col1], this->values[this->getColCount() * i + col2]);
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::transpose () const{
	MatT<T> result { this->getColCount (), this->getRowCount () };
	for (u32 row = 0; row < this->getRowCount(); ++row) {
		for (u32 col = 0; col < this->getColCount(); ++col) {
			result.setValue ( col, row, this->get ( row, col ) );
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::inverse () const {
	LUDecompositionT<T> LUD ( *this );
	MatT inv{ this->getColCount (), this->getColCount () };
	for (u32 i = 0; i < this->getColCount (); i++) {
		VecT<T> b ( this->getColCount () );
		b[i] = T(1.0);
		VecT<T> w = LUD.solve ( b );
		inv.setColValues ( i, w );
	}
	return inv;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::operator == ( const MatT<T> &other ) const {
	return this->equal ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::operator != ( const MatT<T> &other ) const {
	return ! this->equal ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::operator + ( const MatT<T> &other ) const {
	assert ( this->getColCount () == other.getColCount () && this->getRowCount () == other.getRowCount () );
	MatT<T> result { this->getRowCount (), this->getColCount () };
	for (u32 row = 0; row < this->getRowCount (); row++) {
		for (u32 col = 0; col <  this->getColCount (); col++) {
			result.setValue ( row, col, this->get ( row, col ) + other.get ( row, col ) );
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator += ( const MatT<T> &other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>:: operator - ( const MatT &other ) const {
	assert ( this->getColCount () == other.getColCount () && this->getRowCount () == other.getRowCount () );
	MatT<T> result { this->getRowCount (), this->getColCount () };
	for (u32 row = 0; row < this->getRowCount (); row++) {
		for (u32 col = 0; col < this->getColCount (); col++) {
			result.setValue ( row, col, this->get ( row, col ) - other.get ( row, col ) );
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator -= ( const MatT &other ) {
	*this = *this - other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>:: operator * ( T val ) const {
	MatT<T> result { this->getRowCount (), this->getColCount () };
	for (u32 row = 0; row < this->getRowCount (); row++) {
		for (u32 col = 0; col < this->getColCount (); col++) {
			result.setValue ( row, col, this->get ( row, col ) * val );
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::operator * ( VecT<T> other ) const {
	u32 thisRowSize = this->getRowCount ();
	u32 thisColSize = this->getColCount ();
	VecT<T> result ( thisRowSize );
	if ( thisColSize != other.size () ) { return result; }
	for ( u32 i = 0; i < thisRowSize; i++ ) {
		f32 val = 0;
		for ( u32 j = 0; j < thisColSize; j++ ) {
			val += this->get ( i, j ) * other.get ( j );
		}
		result.set ( i, val );
	}
	return result;
}