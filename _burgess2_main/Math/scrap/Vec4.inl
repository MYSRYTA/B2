
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T () 
	: x { 0 }
	, y { 0 }
	, z { 0 }
	, t { 0 }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( T val ) 
	: x { val }
	, y { val }
	, z { val }
	, t { val }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( T setX, T setY, T setZ, T setT ) 
	: x { setX }
	, y { setY }
	, z { setZ }
	, t { setT } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( const VecT<T> &val ) {
	assert ( 4 <= val.size () );
	*this = { val [0], val [1], val [2], val [3] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( const QuatT<T> &val ){
	*this = { val[0], val[1], val[2], val[3] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( const std::vector<T> &val ) {
	assert ( 4 <= val.size () );
	*this = { val [0], val [1], val [2], val [3] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>::Vec4T ( const Vec3T<T> &val ) 
	: x {val.x}
	, y {val.y}
	, z {val.z}
	, t {0.0}
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .z .tごとに最小値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::getMin ( const Vec4T& other ) const {
	return Vec4T { Math::Min ( this->x, other.x ), Math::Min ( this->y, other.y ), Math::Min ( this->z, other.z ), Math::Min ( this->t, other.t )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .z .tごとに最大値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::getMax ( const Vec4T& other ) const {
	return Vec4T { Math::Max ( this->x, other.x ), Math::Max ( this->y, other.y ), Math::Max ( this->z, other.z ), Math::Max ( this->t, other.t )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x .y .z .tごとにlimitの範囲に制限したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::clamp ( const Vec4T& limitVal0, const Vec4T& limitVal1 ) const {
	Vec4T<T> min = limitVal0.getMin ( limitVal1 );
	Vec4T<T> max = limitVal0.getMax ( limitVal1 );

	Vec4T result;
	result.x = Math::Clamp ( this->x, min.x, max.x );
	result.y = Math::Clamp ( this->y, min.y, max.y );
	result.z = Math::Clamp ( this->z, min.z, max.z );
	result.t = Math::Clamp ( this->t, min.t, max.t );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::lerp ( const Vec4T& other, f32 t ) const {
	return *this + ( ( other - *this ) * t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::linearInterpolate ( const Vec4T& other, f32 t ) const {
	return this->lerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::length () const {
	return std::sqrt ( this->lengthSquared () );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::lengthSquared () const {
	return this->dot ( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::setNormal () {
	assert ( Math::IsZero ( this->lengthSquared () )  == false );
	*this = *this / this->length ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::setUnit () {
	this->setNormal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::normal () const {
	assert ( Math::IsZero ( this->lengthSquared () )  == false );
	return *this / this->length ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::unit () const {
	return this->normal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     反転ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::negate () const {
	return Vec4T { -this->x, -this->y, -this->z, -this->t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::inverse () const {
	assert (
		Math::IsZero ( this->x ) == false &&
		Math::IsZero ( this->y ) == false &&
		Math::IsZero ( this->z ) == false &&
		Math::IsZero ( this->t ) == false );

	return Vec4T { T ( 1.0 ) / this->x, T ( 1.0 ) / this->y, T ( 1.0 ) / this->z, T ( 1.0 ) / this->t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::dot ( const Vec4T& other ) const {
	return this->x * other.x + this->y * other.y + this->z * other.z + this->t * other.t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの単位ベクトルの間の角度を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::normalAngleTo ( const Vec4T& other ) const {
	T dot = Math::Clamp ( this->dot ( other ), T(-1.0), T(1.0) );
	return std::acos ( dot );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの単位ベクトルの間の角度を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::unitsAngleTo ( const Vec4T& other ) const {
	return this->normalAngleTo ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの間の角度を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::angleTo ( const Vec4T& other ) const {
	return this->normal ().normalAngleTo ( other.normal () );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの距離を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec4T<T>::distanceTo ( const Vec4T& other ) const {
	return ( *this - other ).length ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		2つのベクトルの距離が指定した値未満の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec4T<T>::distanceLessThan ( const Vec4T& other, T dist ) const {
	Vec4T offset = ( *this - other ) / dist;
	return offset.lengthSquared () < T(1.0);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Vec4T<T>::toVec () const {
	return VecT<T> { this->x, this->y, this->z, this->t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Type配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Vec4T<T>::toTypeArray () const {
	return std::vector<T> { this->x, this->y, this->z, this->t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Vec4T<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	return t + "Vec4:[" + GetFloorString ( this->x ) + ", " + GetFloorString ( this->y ) + ", " + GetFloorString ( this->z ) + ", " + GetFloorString ( this->t ) + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec4T<T>::equal ( const Vec4T& other ) const {
	return	( this->x == other.x ) && ( this->y == other.y ) && ( this->z == other.z ) && ( this->t == other.t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec4T<T>::almostEqual ( const Vec4T& other, T tolerance ) const {
	return
		( std::abs ( this->x - other.x ) < tolerance ) &&
		( std::abs ( this->y - other.y ) < tolerance ) &&
		( std::abs ( this->z - other.z ) < tolerance ) &&
		( std::abs ( this->t - other.t ) < tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x,y,z,tへ[0~3]としてアクセスする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec4T<T>::operator[]( u8 id ) {
	assert ( id < 4 );
	switch ( id ) {
	case 0:
		return this->x;
	case 1:
		return this->y;
	case 2:
		return this->z;
	case 3:
		return this->t;
	}
	return this->x;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec4T<T>::operator[]( u8 id ) const {
	assert ( id < 4 );
	switch ( id ) {
	case 0:
		return this->x;
	case 1:
		return this->y;
	case 2:
		return this->z;
	case 3:
		return this->t;
	}
	return this->x;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec4T<T>::operator==( const Vec4T& other ) const {
	return this->x == other.x && this->y == other.y && this->z == other.z && this->t == other.t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec4T<T>::operator!=( const Vec4T& other ) const {
	return this->x != other.x || this->y != other.y || this->z != other.z || this->t != other.t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator+( const Vec4T& other ) const {
	return Vec4T<T> { this->x + other.x, this->y + other.y, this->z + other.z, this->t + other.t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator+=( const Vec4T& other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator-( const Vec4T& other ) const {
	return Vec4T<T> { this->x - other.x, this->y - other.y, this->z - other.z, this->t - other.t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator-=( const Vec4T& other ) {
	*this = *this - other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator*( const Vec4T& other ) const {
	return Vec4T { this->x * other.x, this->y * other.y, this->z * other.z, this->t * other.t };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator*( T val ) const {
	return *this * Vec4T<T> { val };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator*=( T val ) {
	*this = *this * val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator*=( const Vec4T& other ) {
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator/( const Vec4T& other ) const {
	return Vec4T<T> { this->x / other.x, this->y / other.y, this->z / other.z, this->t / other.t };;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Vec4T<T>::operator/( T val ) const {
	return *this / Vec4T<T> { val };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator/=( const Vec4T& other ) {
	*this = *this / other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec4T<T>::operator/=( T val ) {
	*this = *this / Vec4T<T> { val };
}
