//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ()
	: x{ 0 }
	, y{ 0 }
	, z{ 0 }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( T val )
	: x{ val }
	, y{ val }
	, z{ val }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( T setX, T setY, T setZ )
	: x{ setX }
	, y{ setY }
	, z{ setZ }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( const VecT<T> &val ){
	assert ( 3 <= val.size () );
	*this = { val[0], val[1], val[2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( const Rad3T<T> &val ){
	*this = { val[0], val[1], val[2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( const Deg3T<T> &val ){
	*this = { val[0], val[1], val[2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T ( const std::vector<T> &val ){
	assert ( 3 <= val.size () );
	*this = { val[0], val[1], val[2] };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Vec3T<T>::toVec () const{
	return VecT<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Vec3T<T>::toTypeArray () const{
	return std::vector<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Vec3T<T>::toString ( const String title ) const{
	String t = title;
	if ( title.length () != 0 ){ t += " : "; }
	return t + "Vec3:[" + GetFloorString ( this->x ) + ", " + GetFloorString ( this->y ) + ", " + GetFloorString ( this->z ) + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .zごとに最小値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::getMin ( const Vec3T& other ) const{
	return Vec3T{ Math::Min ( this->x, other.x ), Math::Min ( this->y, other.y ), Math::Min ( this->z, other.z ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .zごとに最大値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::getMax ( const Vec3T& other ) const{
	return Vec3T{ Math::Max ( this->x, other.x ), Math::Max ( this->y, other.y ), Math::Max ( this->z, other.z ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x .y .zごとにlimitの範囲に制限したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::clamp ( const Vec3T& limitVal0, const Vec3T& limitVal1 ) const{
	Vec3T min = limitVal0.getMin ( limitVal1 );
	Vec3T max = limitVal0.getMax ( limitVal1 );
	return	Vec3T<T> { Math::Clamp ( this->x, min.x, max.x ), Math::Clamp ( this->y, min.y, max.y ), Math::Clamp ( this->z, min.z, max.z ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::lerp ( const Vec3T& other, T t ) const{
	return *this + ( ( other - *this ) * t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと球面補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::slerp ( const Vec3T& other, T t ) const{
	if ( this->almostEqual ( other ) ){ return *this; }

	Vec3T<T> v = Math::AlmostEqual ( this->lengthSquared (), T ( 1.0 ) ) ? *this : this->unit ();
	Vec3T<T> o = Math::AlmostEqual ( other.lengthSquared (), T ( 1.0 ) ) ? other : other.unit ();
	T d = v.dot ( o );
	T angle = std::acos ( d );
	T sinTh = std::sin ( angle );

	T s = std::sin ( angle * ( T ( 1.0 ) - t ) );
	T e = std::sin ( angle * t );
	Vec3T<T> r = ( ( s * v ) + ( e * o ) ) / sinTh;
	return r.unit ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::linearInterpolate ( const Vec3T& other, T t ) const{
	return this->lerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと球面補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::sphericalLinearInterpolate ( const Vec3T& other, T t ) const{
	return this->slerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2乗の長さを返す(高負荷のstd::sqrt(平方根)を用いる.length()よりも軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::lengthSquared () const{
	return this->dot ( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.lengthSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::length () const{
	return std::sqrt ( this->lengthSquared () );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2乗の長さを返す(高負荷のstd::sqrt(平方根)を用いる.length()よりも軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::magnitudeSquared () const{
	return this->lengthSquared ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.magnitudeSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::magnitude () const{
	return this->length ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setNormal (){
	assert ( Math::IsZero ( this->lengthSquared () ) == false );
	if (Math::AlmostEqual(this->lengthSquared(), T(1.0))) {
		return;
	} else {
		*this = *this / this->length();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setUnit (){
	this->setNormal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さが0でなければtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::isNotZeroLength () const{
	return Math::IsZero ( this->lengthSquared () ) == false;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::normal () const{
	assert ( Math::IsZero ( this->lengthSquared () ) == false );
	if(Math::AlmostEqual(this->lengthSquared(), T(1.0))){
		return *this;
	} else {
		return *this / this->length();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::unit () const{
	return this->normal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     反転ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::negate () const{
	return Vec3T{ -this->x, -this->y, -this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     反転ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setNegate (){
	*this = this->negate ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::inverse () const{
	assert ( Math::IsZero ( this->x ) == Math::IsZero ( this->y ) == Math::IsZero ( this->z ) == false );
	return Vec3T{ T ( 1.0 ) / this->x, T ( 1.0 ) / this->y, T ( 1.0 ) / this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setInverse (){
	*this = this->inverse ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    反射ベクトルを返す
//!	    @brief	反射ベクトルを返す
//!		@param[in] normal 反射面の法線 (単位ベクトル)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::reflect ( const Vec3T& normal ) const{
	return *this - normal * T ( 2.0 ) * this->dot ( normal );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    反射ベクトルにする
//!	    @brief	反射ベクトルを返す
//!		@param[in] normal 反射面の法線 (単位ベクトル)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setReflect ( const Vec3T& normal ){
	*this = this->reflect ( normal );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::dot ( const Vec3T& other ) const{
	return this->x * other.x + this->y * other.y + this->z * other.z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す (SplineLibrary用)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::dotProduct ( Vec3T &v, Vec3T &other ){
	return v.dot ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     外積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::cross ( const Vec3T& other ) const{
	return Vec3T<T>{
		this->y * other.z - this->z * other.y,
		this->z * other.x - this->x * other.z,
		this->x * other.y - this->y * other.x };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの単位ベクトルの間の角度(ラジアン単位)を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::normalAngleTo ( const Vec3T& other ) const{
	T dot = Math::Clamp ( this->dot ( other ), T ( -1.0 ), T ( 1.0 ) );
	if ( Math::AlmostEqual( dot, T( 1.0 ) ) ) {
		return T( 0.0 );
	} else {
		return std::acos( dot );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの単位ベクトルの間の角度(ラジアン単位)を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::unitsAngleTo ( const Vec3T& other ) const{
	return this->normalAngleTo ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの間の角度(ラジアン単位)を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::angleTo ( const Vec3T& other ) const{
	return this->normal ().normalAngleTo ( other.normal () );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの距離を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::distanceTo ( const Vec3T& other ) const{
	if ( this->almostEqual( other ) ) {
		return T( 0.0 );
	}
	return ( *this - other ).length ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの距離が指定した値未満の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::distanceLessThan ( const Vec3T& other, T dist ) const{
	Vec3T offset = ( *this - other ) / dist;
	return offset.lengthSquared () < T ( 1.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::rotate ( const QuatT<T> &rot ) const{
	return rot.rotatVector ( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::rotate ( const Rad3T<T> &rot ) const{
	return rot.rotatVector ( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::rotate ( const Deg3T<T> &rot ) const{
	return rot.rotatVector ( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     このベクトルから対象ベクトルまでの回転量を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
/// QuaternionAxisToAxis_C
template <typename T>
QuatT<T> Vec3T<T>::rotateTo ( const Vec3T<T> &other ) const{
	QuatT<T> result;

	if ( Math::AlmostEqual ( this->length (), T ( 0.0 ) ) || Math::AlmostEqual ( other.length (), T ( 0.0 ) ) ){
		return result;
	}
	Vec3T<T> restVec3;
	Vec3T<T> Axis0 = this->unit ();
	Vec3T<T> Axis1 = other.unit ();

	T CosTheta = Axis0.dot ( Axis1 );

	if ( Math::AlmostEqual ( CosTheta, T ( -1.0 ) ) || Math::AlmostEqual ( CosTheta, T ( 1.0 ) ) ){
		restVec3.x = T ( 0.0 );
		restVec3.y = Axis0.x;
		restVec3.z = -Axis0.y;

		if ( restVec3.length () < T ( Burgess::TOLERANCE ) ){
			restVec3.x = -Axis0.z;
			restVec3.y = T ( 0.0 );
			restVec3.z = Axis0.x;
		}

		restVec3.setUnit ();

		result.v.x = restVec3.x;
		result.v.y = restVec3.y;
		result.v.z = restVec3.z;
		result.w = T ( 0.0 );

		return result;
	}
	restVec3 = Axis0.cross ( Axis1 );
	restVec3.setUnit ();
	restVec3 *= std::sqrt ( T ( 0.5 ) * ( T ( 1.0 ) - CosTheta ) );

	result.v.x = restVec3.x;
	result.v.y = restVec3.y;
	result.v.z = restVec3.z;
	result.w = std::sqrt ( T ( 0.5 ) * ( T ( 1.0 ) + CosTheta ) );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::equal ( const Vec3T& other ) const{
	return ( this->x == other.x ) && ( this->y == other.y ) && ( this->z == other.z );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostEqual ( const Vec3T& other, T tolerance ) const{
	return	( std::abs ( this->x - other.x ) < tolerance ) &&
		( std::abs ( this->y - other.y ) < tolerance ) &&
		( std::abs ( this->z - other.z ) < tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     0ベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::isZero () const {
	return	this->isNotZeroLength () == false;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    2つのベクトルが完全に並行の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::parallel ( const Vec3T& other ) const{
	Vec3T v0 = this->normal ();
	Vec3T v1 = other.normal ();
	T dot = v0.dot ( v1 );
	return dot == T ( -1.0 ) || dot == T ( 1.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが誤差範囲内で並行の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostParallel ( const Vec3T& other, T tolerance ) const{
	T precisionClamp = Math::Clamp ( tolerance, T ( 0.0 ), T ( 1.0 ) );
	Vec3T v0 = this->normal ();
	Vec3T v1 = other.normal ();
	T dot = v0.dot ( v1 );
	return dot < T ( -1.0 ) + precisionClamp || T ( 1.0 ) - precisionClamp < dot;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが完全に同方向の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::sameDirection ( const Vec3T& other, Bool unitVector ) const{
	if (unitVector) {
		return this->angleTo ( other ) == T ( 0.0 );
	} else {
		if (Math::AlmostEqual ( this->length (), T ( 0.0 ) ) || Math::AlmostEqual ( other.length (), T ( 0.0 ) )) {
			return true;
		}
		Vec3T<T> v0 = this->unit ();
		Vec3T<T> v1 = other.unit ();
		return v0.angleTo ( v1 ) == T ( 0.0 );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが誤差範囲内で同方向の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostSameDirection ( const Vec3T& other, T tolerance, Bool unitVector ) const{
	T precisionClamp = Math::Clamp ( tolerance, T ( 0.0 ), T ( 6.28318531 ) );
	if (unitVector) {
		return this->angleTo ( other ) < precisionClamp;
	} else {
		T thisLen = this->length ();
		T otherLen = other.length ();
		if (Math::AlmostEqual ( thisLen, T ( 0.0 ), tolerance ) ||
			Math::AlmostEqual ( otherLen, T ( 0.0 ), tolerance )) {
			return true;
		}
		Vec3T<T> v0 = *this / thisLen;
		Vec3T<T> v1 = other / otherLen;
		return v0.angleTo ( v1 ) < precisionClamp;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x,y,zへ[0~2]としてアクセスする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec3T<T>::operator[]( u8 id ){
	assert ( id < 3 );
	switch ( id ){
		case 0:
			return this->x;
		case 1:
			return this->y;
		case 2:
			return this->z;
	}
	return this->x;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec3T<T>::operator[]( u8 id ) const{
	assert ( id < 3 );
	switch ( id ){
		case 0:
			return this->x;
		case 1:
			return this->y;
		case 2:
			return this->z;
	}
	return this->x;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::operator==( const Vec3T& other ) const{
	return this->x == other.x && this->y == other.y && this->z == other.z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::operator !=( const Vec3T& other ) const{
	return this->x != other.x || this->y != other.y || this->z != other.z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator+( const Vec3T& other ) const{
	return Vec3T<T> { this->x + other.x, this->y + other.y, this->z + other.z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator+=( const Vec3T& other ){
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator -( const Vec3T& other ) const{
	return Vec3T<T> { this->x - other.x, this->y - other.y, this->z - other.z };;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator -=( const Vec3T& other ){
	*this = *this - other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator*( const Vec3T& other ) const{
	return Vec3T{ this->x * other.x, this->y * other.y, this->z * other.z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator*( T val ) const{
	return *this * Vec3T<T> ( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator*=( T val ){
	*this = *this * val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator*=( const Vec3T& other ){
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator/( const Vec3T& other ) const{
	return Vec3T<T> { this->x / other.x, this->y / other.y, this->z / other.z };;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator/( T val ) const{
	return *this / Vec3T<T> ( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator/=( const Vec3T& other ){
	*this = *this / other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator/=( T val ){
	*this = *this / Vec3T<T> ( val );
}