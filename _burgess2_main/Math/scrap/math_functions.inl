namespace Math {
	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		小さい方の値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 Type Min ( Type val1, Type val2 ) {
		return val1 > val2 ? val2 : val1;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		大きい方の値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 Type Max ( Type val1, Type val2 ) {
		return val1 < val2 ? val2 : val1;
	}
	 
	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		nim~maxの範囲内に収めた値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	 T Clamp ( T val, T min, T max ) {
		return ( val < min ? min : ( val > max ? max : val ) );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		inValをinMin-inMaxの範囲からoutMin-outMaxの範囲へリスケールした値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	f32 Rescale ( f32 inVal, f32 inMin, f32 inMax, f32 outMin, f32 outMax ) {
		return outMin + ( outMax - outMin ) * ( inVal - inMin ) / ( inMax - inMin );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   inValをinMin-inMaxの範囲からoutMin-outMaxの範囲へリスケールした値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f64 Rescale ( f64 inVal, f64 inMin, f64 inMax, f64 outMin, f64 outMax ) {
		return outMin + ( outMax - outMin ) * ( inVal - inMin ) / ( inMax - inMin );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてfloat AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f32 Lerp ( f32 valA, f32 valB, f32 t ) {
		return valA + ( ( valB - valA ) * t );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてdouble AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f64 Lerp ( f64 valA, f64 valB, f64 t ) {
		return valA + ( ( valB - valA ) * f64(t) );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてfloat AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f32 LinearInterpolate ( f32 valA, f32 valB, f32 t ) {
		return Lerp ( valA, valB, t );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてdouble AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f64 LinearInterpolate ( f64 valA, f64 valB, f64 t ) {
		return Lerp ( valA, valB, t );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   min~max範囲内におけるvalのt値(0.0~1.0)を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f32 ReverseLerp ( f32 val, f32 minVal, f32 maxVal ) {
		return ( ( val - minVal ) / ( maxVal - minVal ) );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   min~max範囲内におけるvalのt値(0.0~1.0)を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 f64 ReverseLerp ( f64 val, f64 minVal, f64 maxVal ) {
		return f64 ( ( val - minVal ) / ( maxVal - minVal ) );
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 s32 TreeInterpolate(const std::vector<s32>& tree, s32 key, s32& remainder) {
		 s32 lowID = 1;
		 s32 highID = s32(tree.size());
		 /* テーブル内を2分割しながら検索 */
		 while (lowID < highID) {
			 s32 midID = (lowID + highID) / 2;
			 if (tree[midID] <= key) {
				 lowID = midID + 1;
			 } else {
				 highID = midID;
			 }
		 }
		 remainder = s32( key - tree[lowID - 1] );
		 return lowID - 1;
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 s32 TreeInterpolate(const std::vector<s32>& tree, s32 key) {
		 s32 dummy;
		 return TreeInterpolate(tree, key, dummy);
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 u32 TreeInterpolate ( const std::vector<u32> &tree, u32 key, u32 &remainder ) {
		 u32 lowID = 1;
		 u32 highID = u32(tree.size ());
		 /* テーブル内を2分割しながら検索 */
		 while ( lowID < highID ) {
			 u32 midID = ( lowID + highID ) / 2;
			 if ( tree [midID] <= key ) {
				 lowID = midID + 1;
			 } else {
				 highID = midID;
			 }
		 }
		 remainder = key - tree[lowID-1];
		 return lowID - 1;
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 u32 TreeInterpolate ( const std::vector<u32> &tree, u32 key ) {
		 u32 dummy;
		 return TreeInterpolate ( tree, key, dummy );
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 u32 TreeInterpolate ( const std::vector<f32> &tree, f32 key, f32 &remainder ) {
		 u32 lowID = 1;
		 u32 highID = u32(tree.size ());
		 /* テーブル内を2分割しながら検索 */
		 while ( lowID < highID ) {
			 u32 midID = ( lowID + highID ) / 2;
			 if ( tree [midID] <= key ) {
				 lowID = midID + 1;
			 } else {
				 highID = midID;
			 }
		 }
		 remainder = key - tree [lowID-1];
		 return lowID - 1;
	 }

	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 //!	   ２分木探索  keyが所属するtree内の配列番号を返す
	 //------------------------------------------------------------------------------------------------------------------------------------------------
	 u32 TreeInterpolate ( const std::vector<f32> &tree, f32 key ) {
		 f32 dummy;
		 return TreeInterpolate ( tree, key, dummy );
	 }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 template<typename T>
	 std::vector<T> FillInterpolated ( T a, T b, u32 count, Bool popFirst, Bool popLast ) {
		 u32 size = count;
		 if (popFirst) { size -= 1; }
		 if (popLast) { size -= 1; }
		 std::vector<T> result( size );
		 u32 o = popFirst ? 1 : 0;
		 T e = T(1.0) / T(size);
		 for ( u32 i = o; i<size; i++ ) {
			 T ratio = e * i;
			 result [i-o] = ( T(1.0) - ratio ) * a + ratio * b;
		 }
		 return result;
	 }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   2つの値が誤差範囲内で同じであればtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool AlmostEqual ( f32 valA, f32 valB, f32 tolerance ) {
		return std::abs ( valA - valB ) < tolerance;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   2つの値が誤差範囲内で同じであればtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool AlmostEqual ( f64 valA, f64 valB, f64 tolerance ) {
		return std::abs ( valA - valB ) < tolerance;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が限りなく0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool IsZero ( f32 val ) {
		return -Burgess::TOLERANCE < val&& val < Burgess::TOLERANCE;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が限りなく0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool IsZero ( f64 val ) {
		return  -Burgess::TOLERANCE < val && val < Burgess::TOLERANCE;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が誤差範囲内で0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool AlmostZero ( f32 val, f32 tolerance ) {
		 return val < tolerance && val > -tolerance;
	 }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が誤差範囲内で0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 Bool AlmostZero ( f64 val, f64 tolerance ) {
		 return val < tolerance&& val > -tolerance;
	 }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   float配列を昇順(降順)でソートする。元の配列番号をarrayOrigIDに返す
	//!		@param[in, out] arrayVal ソート対象となる配列
	//!		@param[out] arrayOrigID ソート前の配列番号
	//!		@param[in] descendingOrder true=降順
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	void Sort ( IO std::vector<Type> &arrayVal, OUT std::vector<u32> &arrayOrigID, Bool descendingOrder ) {
		s32 cnt = s32(arrayVal.size ());
		if ( cnt == 0 ) { return; }
		
		arrayOrigID.resize ( cnt );

		std::vector<std::vector<Type>> val_id ( cnt );
		#pragma omp parallel for if(300 < cnt)
		for ( s32 i = 0; i < cnt; i++ ) {
			val_id[i].resize ( 2 );
			val_id[i][0] = arrayVal[i];
			val_id[i][1] = i;
		}
		std::sort ( val_id.begin (), val_id.end () );

		if ( descendingOrder ) {
			#pragma omp parallel for if(300 < cnt)
			for ( s32 i = 0; i < cnt; i++ ) {
				u32 ii = cnt - i - 1;
				arrayVal[i] = val_id[ii][0];
				arrayOrigID[i] = u32 ( val_id[ii][1] );
			}
		} else {
			#pragma omp parallel for if(300 < cnt)
			for ( s32 i = 0; i < cnt; i++ ) {
				arrayVal[i] = val_id[i][0];
				arrayOrigID[i] = u32 ( val_id[i][1] );
			}
		}
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   float配列を昇順(降順)でソートする。
	//!		@param[in, out] arrayVal ソート対象となる配列
	//!		@param[in] descendingOrder true=降順
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 void Sort ( IO std::vector<Type> &arrayVal, Bool descendingOrder ) {
		std::vector<u32> dummy;
		Math::Sort ( arrayVal, dummy, descendingOrder );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最低値の配列要素を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 Type Minimum ( const std::vector<Type> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		Type smallest = arrayVal [0];
		s32 loopCnt = arrayVal.size ();
		if ( loopCnt < 1000 ) {
			for ( u32 i = 1; i < arrayVal.size (); i++ ) {
				if ( arrayVal [i] < smallest ) {
					smallest = arrayVal [i];
				}
			}
		} else {
			{
				Type min = std::numeric_limits<Type>::max ();
				u32 valCnt = arrayVal.size ();
				#pragma omp for nowait
				for ( s32 ii = 0; ii<valCnt; ++ii ) {
					min = Math::Min ( arrayVal [ii], min );
				}
				#pragma omp critical 
				{
					smallest = Math::Min ( smallest, min );
				}
			}
		}
		return smallest;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最大値の配列要素を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 Type Maximum ( const std::vector<Type> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		Type biggest = arrayVal [0];
		for ( u32 i = 1; i < arrayVal.size (); i++ ) {
			if ( biggest < arrayVal [i] ) {
				biggest = arrayVal [i];
			}
		}
		return biggest;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最低値の配列要素のIndexを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 u32 MinimumIndex ( const std::vector<Type> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		Type smallest = arrayVal [0];
		u32 result = 0;
		s32 loopCnt = arrayVal.size ();
		for ( u32 i = 1; i < loopCnt; i++ ) {
			if ( arrayVal [i] < smallest ) {
				smallest = arrayVal [i];
				result = i;
			}
		}
		return result;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最大値の配列要素のIndexを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename Type>
	 u32 MaximumIndex ( const std::vector<Type> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		Type biggest = arrayVal [0];
		u32 result = 0;
		for ( u32 i = 1; i < arrayVal.size (); i++ ) {
			if ( biggest < arrayVal [i] ) {
				biggest = arrayVal [i];
				result = i;
			}
		}
		return result;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   radian値をdegree値へ変換する
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 template<typename Type>
	 Type RadToDeg ( Type rad ) { return rad * Type(Burgess::RAD); }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   degree値をradian値へ変換する
	//------------------------------------------------------------------------------------------------------------------------------------------------
	 template<typename Type>
	 Type DegToRad ( Type deg ) { return deg * Type(Burgess::PI_DIV_180); }

}