//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT() : Eigen::Quaternion<T>{ Eigen::Quaternion<T>::Identity() }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( T _x, T _y, T _z, T _w ) : Eigen::Quaternion<T>( _w, _x, _y, _z )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     val[0,1,2]=v, val[3]=w 
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const std::vector<T>& val ) : Eigen::Quaternion<T>(){
	if ( val.size() < 4 ){
		*this = Eigen::Quaternion<T>::Identity();
	} else{
		*this = Eigen::Quaternion<T>( val[3], val[0], val[1], val[2] );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     val[0,1,2]=v, val[3]=w 
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const VecT<T>& val ) : Eigen::Quaternion<T>(){
	if ( val.size() < 4 ){
		*this = Eigen::Quaternion<T>::Identity();
	} else{
		*this = Eigen::Quaternion<T>( val[3], val[0], val[1], val[2] );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Vec3T<T>& _v, T _w ) : Eigen::Quaternion<T>( _w, _v[0], _v[1], _v[2] )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     val[0,1,2]=v, val[3]=w 
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Vec4T<T>& val ) : Eigen::Quaternion<T>( val[3], val[0], val[1], val[2] )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Rad3T<T>& rad ) : Eigen::Quaternion<T>(){
	this->setFromRad3( rad );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Deg3T<T>& deg ) : Eigen::Quaternion<T>(){
	this->setFromDeg3( deg );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Mat3T<T>& mat ) : Eigen::Quaternion<T>(){
	this->setFromMat3( mat );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Mat4T<T>& mat ) : Eigen::Quaternion<T>(){
	this->setFromMat3( mat.getRotationMat3() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const QuatT<T>& val ) : Eigen::Quaternion<T>(){
	*this = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Eigen::Matrix<T, 3, 3>& mat ){
	this->Eigen::Quaternion<T>::operator=( mat );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT( const Eigen::Quaternion<T>& other ){
	this->Eigen::Quaternion<T>::operator=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.xへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::x(){ return this->Eigen::Quaternion<T>::x(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.xへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::x()const{ return this->Eigen::Quaternion<T>::x(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.yへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::y(){ return this->Eigen::Quaternion<T>::y(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.yへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::y()const{ return this->Eigen::Quaternion<T>::y(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.zへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::z(){ return this->Eigen::Quaternion<T>::z(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     v.zへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::z()const{ return this->Eigen::Quaternion<T>::z(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     wへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::w(){ return this->Eigen::Quaternion<T>::w(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     wへのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::w()const{ return this->Eigen::Quaternion<T>::w(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する VecT[0,1,2]=v/[3]=w
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> QuatT<T>::toVec() const{
	return VecT<T> { std::vector<T>{this->x(), this->y(), this->z(), this->w()} };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する std::vector[0,1,2]=v/[3]=w
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> QuatT<T>::toTypeArray() const{
	return std::vector<T>{this->x(), this->y(), this->z(), this->w()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> QuatT<T>::toMat3() const{
	return Mat3T<T>{this->Eigen::Quaternion<T>::toRotationMatrix()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rad3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T> QuatT<T>::toRad3( BURGESS2::RotationOrder order ) const {
	Vec3T<T> result;
	Mat3T<T> mat3 = this->toMat3();

	switch ( static_cast<u8>( order ) ){
		case 0: /// XYZ
			result.y() = std::asin( -Burgess2MathFn::Clamp( mat3(2, 0), T( -1.0 ), T( 1.0 ) ) );
			if ( std::abs( mat3(2, 0) ) < BURGESS2::TOLERANCE0999 ){
				result.x() = std::atan2( mat3(2, 1), mat3(2, 2) );
				result.z() = std::atan2( mat3(1, 0), mat3(0, 0) );
			} else{
				result.x() = T( 0.0 );
				result.z() = std::atan2( -mat3(0, 1), mat3(1, 1) );
			}
			break;
		case 1: /// YZX
			result.z() = std::asin( -Burgess2MathFn::Clamp( mat3( 0, 1 ), T( -1.0 ), T( 1.0 ) ) );
			if(std::abs( mat3( 0, 1 ) ) < BURGESS2::TOLERANCE0999){
				result.x() = std::atan2( mat3( 2, 1 ), mat3( 1, 1 ) );
				result.y() = std::atan2( mat3( 0, 2 ), mat3( 0, 0 ) );
			} else{
				result.x() = std::atan2( -mat3( 1, 2 ), mat3( 2, 2 ) );
				result.y() = T( 0.0 );
			}
			break;
		case 2: /// ZXY
			result.x() = std::asin( -Burgess2MathFn::Clamp( mat3( 1, 2 ), T( -1.0 ), T( 1.0 ) ) );
			if(std::abs( mat3( 1, 2 ) ) < BURGESS2::TOLERANCE0999){
				result.y() = std::atan2( mat3( 0, 2 ), mat3( 2, 2 ) );
				result.z() = std::atan2( mat3( 1, 0 ), mat3( 1, 1 ) );
			} else{
				result.y() = std::atan2( -mat3( 2, 0 ), mat3( 0, 0 ) );
				result.z() = T( 0.0 );
			}
			break;
		case 3:/// XZY
			result.z() = std::asin( Burgess2MathFn::Clamp( mat3( 1, 0 ), T( -1.0 ), T( 1.0 ) ) );
			if(std::abs( mat3( 1, 0 ) ) < BURGESS2::TOLERANCE0999){
				result.x() = std::atan2( -mat3( 1, 2 ), mat3( 1, 1 ) );
				result.y() = std::atan2( -mat3( 2, 0 ), mat3( 0, 0 ) );
			} else{
				result.x() = T( 0.0 );
				result.y() = std::atan2( mat3( 0, 2 ), mat3( 2, 2 ) );
			}
			break;
		case 4: /// YXZ
			result.x() = std::asin( Burgess2MathFn::Clamp( mat3( 2, 1 ), T( -1.0 ), T( 1.0 ) ) );
			if(std::abs( mat3( 2, 1 ) ) < BURGESS2::TOLERANCE0999){
				result.y() = std::atan2( -mat3( 2, 0 ), mat3( 2, 2 ) );
				result.z() = std::atan2( -mat3( 0, 1 ), mat3( 1, 1 ) );
			} else{
				result.y() = 0;
				result.z() = std::atan2( mat3( 1, 0 ), mat3( 0, 0 ) );
			}
			break;
		case 5: /// ZYX
			result.y() = std::asin( Burgess2MathFn::Clamp( mat3(0, 2), T( -1.0 ), T( 1.0 ) ) );
			if ( std::abs( mat3(0, 2) ) < BURGESS2::TOLERANCE0999 ){
				result.x() = std::atan2( -mat3(1, 2), mat3(2, 2) );
				result.z() = std::atan2( -mat3(0, 1), mat3(0, 0) );
			} else{
				result.x() = std::atan2( mat3(2, 1), mat3(1, 1) );
				result.z() = T( 0.0 );
			}
			break;
	}
	return Rad3T<T>{result, order};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Deg3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T> QuatT<T>::toDeg3( BURGESS2::RotationOrder order ) const {
	Rad3T<T> rad = this->toRad3( order );
	return Deg3T<T>{rad};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String QuatT<T>::toString( const String title ) const{
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	return t + "Quat:[" + GetFloorString( this->x() ) + ", " + GetFloorString( this->y() ) + ", " + GetFloorString( this->z() ) + ", " + GetFloorString( this->w() ) + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのクォータニオンの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::equal( const QuatT& other ) const{
	return ( this->x() == other.x() ) && ( this->y() == other.y() ) && ( this->z() == other.z() ) && ( this->w() == other.w() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのクォータニオンの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::almostEqual( const QuatT& other, T tolerance ) const{
	return	( std::abs( this->x() - other.x() ) < tolerance ) &&
			( std::abs( this->y() - other.y() ) < tolerance ) &&
			( std::abs( this->z() - other.z() ) < tolerance ) &&
			( std::abs( this->w() - other.w() ) < tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ゼロクォータニオンの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::isZero() const{
	return this->x() == T( 0.0 ) && this->y() == T( 0.0 ) && this->z() == T( 0.0 ) && this->w() == T( 0.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値が誤差範囲内でゼロクォータニオンの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::almostZero( T tolerance ) const{
	return this->almostEqual( QuatT<T>( T( 0.0 ), T( 0.0 ), T( 0.0 ), T( 0.0 ) ), tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setIdentity(){
	*this = Eigen::Quaternion<T>::Identity();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::set( const Vec3T<T>& v, T w ){
	*this = QuatT<T>{ v, w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromMat3( const Mat3T<T>& mat ){
	*this = Eigen::Quaternion<T>( mat );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     オイラー（ラジアン単位）から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromRad3( const Rad3T<T>& rad ) {
	T sx = std::sin( rad.x() * T( 0.5 ) );
	T sy = std::sin( rad.y() * T( 0.5 ) );
	T sz = std::sin( rad.z() * T( 0.5 ) );
	T cx = std::cos( rad.x() * T( 0.5 ) );
	T cy = std::cos( rad.y() * T( 0.5 ) );
	T cz = std::cos( rad.z() * T( 0.5 ) );

	switch ( static_cast<u8>( rad.getRotationOrder() ) ){
		case 0:/// XYZ
			this->x() = sx * cy * cz - cx * sy * sz;
			this->y() = sx * cy * sz + cx * sy * cz;
			this->z() = cx * cy * sz - sx * sy * cz;
			this->w() = cx * cy * cz + sx * sy * sz;
			break;
		case 1:/// YZX
			this->x() = cy * cz * sx - sy * sz * cx;
			this->y() = sy * cz * cx - cy * sz * sx;
			this->z() = sy * cz * sx + cy * sz * cx;
			this->w() = cy * cz * cx + sy * sz * sx;
			break;
		case 2:/// ZXY
			this->x() = cz * sx * cy + sz * cx * sy;
			this->y() = cz * cx * sy - sz * sx * cy;
			this->z() = -cz * sx * sy + sz * cx * cy;
			this->w() = cz * cx * cy + sz * sx * sy;
			break;
		case 3:/// XZY
			this->x() = sx * cz * cy + cx * sz * sy;
			this->y() = cx * cz * sy + sx * sz * cy;
			this->z() = -sx * cz * sy + cx * sz * cy;
			this->w() = cx * cz * cy - sx * sz * sy;
			break;
		case 4:/// YXZ
			this->x() = cy * sx * cz - sy * cx * sz;
			this->y() = cy * sx * sz + sy * cx * cz;
			this->z() = cy * cx * sz + sy * sx * cz;
			this->w() = cy * cx * cz - sy * sx * sz;
			break;
		case 5:/// ZYX
			this->x() = cz * cy * sx + sz * sy * cx;
			this->y() = cz * sy * cx - sz * cy * sx;
			this->z() = cz * sy * sx + sz * cy * cx;
			this->w() = cz * cy * cx - sz * sy * sx;
			break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     オイラー（デグリー単位）から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromDeg3( const Deg3T<T>& deg ) {
	this->setFromRad3( Rad3T<T> { deg } );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ラジアンから回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromRadian( const Vec3T<T>& radVal, BURGESS2::RotationOrder order ) {
	this->setFromRad3( Rad3T<T> { radVal, order } );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デグリーから回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromDegree( const Vec3T<T>& degVal, BURGESS2::RotationOrder order ) {
	this->setFromRad3( Rad3T<T> { Deg3T<T>{ degVal, order} } );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     軸と角度（ラジアン単位）で定義される回転に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromAxisAndAngle( const Vec3T<T>& axis, T angle ){
	T halfAngle = angle * T( 0.5 );
	this->set( axis.unit() * std::sin( halfAngle ), std::cos( halfAngle ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    方向とアップベクトルから回転を設定する (例：axis=0の場合は direction=Z, upV=Y)
//!		@param[in] type 0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromDirectionAndUpvector( const Vec3T<T>& direction, const Vec3T<T>& upvector, u8 type, Bool dirNeg, Bool upVectorNeg ){
	Mat3T<T> m3;
	m3.setFromDirectionAndUpvector( direction, upvector, type, dirNeg, upVectorNeg );
	this->setFromMat3( m3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     sourcVecからtargetVecまでの回転の差分を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFrom2Vectors( const Vec3T<T>& sourceVec3, const Vec3T<T>& targetVec3 ){
	Vec3T<T> s = sourceVec3.isUnit() ? sourceVec3 : sourceVec3.unit();
	Vec3T<T> t = targetVec3.isUnit() ? targetVec3 : targetVec3.unit();
	
	if( s.almostSameDirection(t)){
		*this = QuatT<T>();
	}else if(s.almostSameDirection(t.negate())){
		*this = QuatT<T>(Deg3T<T>(T(0.0), T(180), T(0.0)));
	}else{
		*this = Eigen::Quaternion<T>::FromTwoVectors( a, t );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     対数クォータニオンからクォータニオンを設定する <br>
//!		参照コード提供元　Mukai Laboratory　https://mukai-lab.org/
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromExpmap( const Vec3T<T>& expmap ){
	T mag = std::sqrt( SQ( expmap[0] ) + SQ( expmap[1] ) + SQ( expmap[2] ) );
	T sina = T(std::abs( mag ) < 1.0e-6 ? 0.0 : std::sin( mag ) / mag);
	//*this = QuatT<T>{ expmap[0] * sina, expmap[1] * sina, expmap[2] * sina, std::cos( mag ) };
	this->x() = expmap[0] * sina;
	this->y() = expmap[1] * sina;
	this->z() = expmap[2] * sina;
	this->w() = std::cos( mag );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値（デグリー）を合算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::addAngle( const Deg3T<T>& deg ) const {
	return (*this) * QuatT<T>{deg};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値（ラジアン）を合算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::addAngle( const Rad3T<T>& rad ) const {
	return (*this) * QuatT<T>{rad};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     X軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getXaxis() const{
	Vec3T<T> result;
	result.x() = T( 1.0 ) - T( 2.0 ) * ( SQ(this->z()) + SQ(this->y()) );
	result.y() = T( 2.0 ) * ( this->x() * this->y() + this->z() * this->w() );
	result.z() = T( 2.0 ) * ( this->x() * this->z() - this->y() * this->w() );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Y軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getYaxis() const{
	Vec3T<T> result;
	result.x() = T( 2.0 ) * ( this->x() * this->y() - this->z() * this->w() );
	result.y() = T( 1.0 ) - T( 2.0 ) * ( SQ(this->z()) + SQ(this->x()) );
	result.z() = T( 2.0 ) * ( this->y() * this->z() + this->x() * this->w() );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Z軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getZaxis() const{
	Vec3T<T> result;
	result.x() = T( 2.0 ) * ( this->y() * this->w() + this->x() * this->z() );
	result.y() = T( 2.0 ) * ( this->y() * this->z() - this->x() * this->w() );
	result.z() = T( 1.0 ) - T( 2.0 ) * ( SQ(this->y()) + SQ(this->x()) );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Axisを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getAxis() const{
	QuatT<T> q = *this;
	if ( T( 1.0 ) < q.w() ){
		q.setNormal();
	}

	T s = std::sqrt( T( 1.0 ) - q.w() * q.w() );
	if ( s < BURGESS2::TOLERANCE ){
		return Vec3T<T>{ q.x(), q.y(), q.z()};
	} else{
		T invS = T( 1.0 ) / s;
		return Vec3T<T>{ q.x()* invS, q.y()* invS, q.z()* invS};
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     アングル（ラジアン単位）を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::getAngle() const{
	return std::acos( this->w() ) * T( 2.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと線形補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::lerp( const QuatT& other, T t ) const{
	return QuatT<T>{
		Burgess2MathFn::Lerp( this->x(), other.x(), t ),
		Burgess2MathFn::Lerp( this->y(), other.y(), t ),
		Burgess2MathFn::Lerp( this->z(), other.z(), t ),
		Burgess2MathFn::Lerp( this->w(), other.w(), t )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと線形補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::linearInterpolate( const QuatT& other, T t ) const{
	return this->lerp( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと球状補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::slerp( const QuatT& other, T t ) const{
	return QuatT<T>{this->Eigen::Quaternion<T>::slerp( t, other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと球状補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::sphericalLinearInterpolate( const QuatT& other, T t ) const{
	return this->slerp( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     クォータニオンの長さを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::length() const{
	return T{this->Eigen::Quaternion<T>::norm()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::lengthSquared() const{
	return T{this->Eigen::Quaternion<T>::squaredNorm()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::dist( const QuatT& other )const{
	QuatT<T> d = this->conjugate() * ( this->dot( other ) < T( 0.0 ) ? other * T( -1.0 ) : other );
	Vec3T<T> rest;
	T angle = d.getAngle();
	return std::abs( angle );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::normal() const{
	return QuatT<T>{this->Eigen::Quaternion<T>::normalized()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setNormal(){
	this->Eigen::Quaternion<T>::normalize();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::unit() const{
	return QuatT<T>{this->normal()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setUnit(){
	this->setNormal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::inverse() const{
	return QuatT<T>{this->Eigen::Quaternion<T>::inverse()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setInverse(){
	*this = this->inverse();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    軸に従って反転したクォータニオンを返す
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::mirror( const BURGESS2::Axis& mirrorAxis ) const{
	QuatT<T> result;
	T restW = this->w();
	switch ( static_cast<u8>(mirrorAxis) ){
		case 1: /// y
			result.set( Vec3T<T>{ -restW, this->z(), this->y() }, -this->x() );
			break;
		case 2: /// z
			result.set( Vec3T<T>{ this->x(), this->y(), -this->z() }, -this->w() );
			break;
		default: /// x
			result.set( Vec3T<T>{ this->z(), restW, this->x() }, this->y() );
			break;
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     軸に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setMirror( const BURGESS2::Axis& mirrorAxis ){
	*this = this->mirror( mirrorAxis );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    リグ用：軸に従って反転したクォータニオンを返す
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::mirror2( const BURGESS2::Axis& mirrorAxis ) const{
	QuatT<T> result{ *this };
	switch ( static_cast<u8>( mirrorAxis ) ){
		case 1: /// y
			result.x() *= T( -1.0 );
			result.z() *= T( -1.0 );
			break;
		case 2: /// z
			result.x() *= T( -1.0 );
			result.y() *= T( -1.0 );
			break;
		default: /// x
			result.y() *= T( -1.0 );
			result.z() *= T( -1.0 );
			break;
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    リグ用：軸に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setMirror2( const BURGESS2::Axis& mirrorAxis ){
	*this = this->mirror2( mirrorAxis );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     共役を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::conjugate() const{
	return QuatT<T>{this->Eigen::Quaternion<T>::conjugate()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     対数クォータニオンを返す
//!	     参照コード提供元　Mukai Laboratory　https://mukai-lab.org/
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::expmap() const{
	QuatT<T> q = this->w() < 0.0 ? *this * -1.0 : *this;
	T isina;
	if ( T( 1.0 - 1.0e-6 ) < std::abs( q.w() ) ){
		isina = T( 0.0 );
	} else{
		T a = std::acos( q.w() );
		isina = a / std::sin( a );
	}
	return Vec3T<T>{this->x(), this->y(), this->z()} *isina;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::dot( const QuatT& other ) const{
	return this->Eigen::Quaternion<T>::dot( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルをこのクォータニオンで回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::rotateVector( const Vec3T<T>& vec3 ) const{
	return Vec3T<T>{this->Eigen::Quaternion<T>::_transformVector( vec3 )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     関数名のタイポ対応
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::rotatVector( const Vec3T<T>& vec3 ) const{
	return this->rotateVector( vec3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>& QuatT<T>::operator = ( const Eigen::Matrix<T, 3, 3>& other ){
	this->Eigen::Quaternion<T>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>& QuatT<T>::operator = ( const Eigen::Quaternion<T>& other ){
	this->Eigen::Quaternion<T>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::operator[]( u8 id ){
	switch ( id ){
		case 0:	return this->Eigen::Quaternion<T>::x();
		case 1:	return this->Eigen::Quaternion<T>::y();
		case 2:	return this->Eigen::Quaternion<T>::z();
		case 3:	return this->Eigen::Quaternion<T>::w();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::operator[]( u8 id )const{
	switch ( id ){
		case 0:	return this->Eigen::Quaternion<T>::x();
		case 1:	return this->Eigen::Quaternion<T>::y();
		case 2:	return this->Eigen::Quaternion<T>::z();
		case 3:	return this->Eigen::Quaternion<T>::w();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::operator == ( const QuatT<T>& other ) const {
	return this->Eigen::Quaternion<T>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::operator != ( const QuatT<T>& other ) const {
	return this->Eigen::Quaternion<T>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator*( const T val ) const {
	return QuatT<T>{this->x()*val, this->y()* val, this->z()* val, this->w()* val};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator*( const QuatT<T>& other ) const {
	return QuatT<T>{Eigen::Quaternion<T>::operator*( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator*=( const T val ) {
	this->x() *= val;
	this->y() *= val;
	this->z() *= val;
	this->w() *= val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator*=( const QuatT<T>& other ) {
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator/( const T val ) const {
	return QuatT<T>{this->x() / val, this->y() / val, this->z() / val, this->w() / val};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator/( const QuatT<T>& other ) const {
	QuatT<T> invQ = other.inverse();
	return QuatT<T> { Eigen::Quaternion<T>::operator*( invQ ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator/=( const T val ) {
	this->x() /= val;
	this->y() /= val;
	this->z() /= val;
	this->w() /= val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator/=( const QuatT<T>& other ) {
	*this = *this / other;
}