//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat4
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T() : Eigen::Matrix<T, 3, 3>{ Eigen::Matrix<T, 3, 3>::Identity( 3, 3 ) }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( T _00, T _01, T _02, T _10, T _11, T _12, T _20, T _21, T _22 ) : Eigen::Matrix<T, 3, 3>(){
	*this << _00, _01, _02, _10, _11, _12, _20, _21, _22;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const Vec3T<T>& _row0, const Vec3T<T>& _row1, const Vec3T<T>& _row2 ) : Eigen::Matrix<T, 3, 3>(){
	*this << _row0[0], _row0[1], _row0[2], _row1[0], _row1[1], _row1[2], _row2[0], _row2[1], _row2[2];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//! 	@param[in] data 
//!		@param[in] columnMajorData dataの値順がcol-majorの場合はtrue
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const VecT<T>& data, Bool argDataIsColumnMajor ) : Eigen::Matrix<T, 3, 3>(){
	if (data.size() < 9 ){
		this->Eigen::Matrix<T, 3, 3>::Identity( 3, 3 );
		return;
	}

	if( argDataIsColumnMajor ){
		*this = Eigen::Map<Eigen::Matrix<T, 3, 3>>( data.toTypeArray().data() );
	} else{
		*this << data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//!		@param[in] typeArray 
//!		@param[in] columnMajorData dataの値順がcol-majorの場合はtrue
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( std::vector<T>& data, Bool argDataIsColumnMajor ) : Eigen::Matrix<T, 3, 3>(){
	if (data.size() < 9 ){
		this->Eigen::Matrix<T, 3, 3>::Identity( 3, 3 ); 
		return;
	}

	if( argDataIsColumnMajor ){
		*this = Eigen::Map<Eigen::Matrix<T, 3, 3>>( data.data() );
	} else{
		*this << data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const QuatT<T>& quat ) : Eigen::Matrix<T, 3, 3>( quat.toMat3() )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const Rad3T<T>& rad ) : Eigen::Matrix<T, 3, 3>( rad.toMat3() )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const Deg3T<T>& deg ) : Eigen::Matrix<T, 3, 3>( deg.toMat3() )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>::Mat3T( const Eigen::Matrix<T, 3, 3>& other ) : Eigen::Matrix<T, 3, 3>( other )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Mat3T<T>::toVec( Bool columnMajorData ) const{
	return Vec( this->toTypeArray( columnMajorData ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列に変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Mat3T<T>::toTypeArray( Bool columnMajorData )const{
	std::vector<T> stdVec( 9 );
	if(columnMajorData){
		Eigen::Map<Eigen::Matrix<T, 3, 3>>( stdVec.data(), 3, 3 ) = *this;
	} else{
		stdVec = std::vector<T>{ this->get( 0, 0 ), this->get( 0, 1 ), this->get( 0, 2 ),
								this->get( 1, 0 ), this->get( 1, 1 ), this->get( 1, 2 ),
								this->get( 2, 0 ), this->get( 2, 1 ), this->get( 2, 2 )};
	}
	return stdVec;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Mat3T<T>::toString( const String title ) const{
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	String row0 = "row0 [" + GetFloorString( this->get(0,0) ) + ", " + GetFloorString( this->get(0,1) ) + ", " + GetFloorString( this->get(0,2) ) + "] / ";
	String row1 = "row1 [" + GetFloorString( this->get(1,0) ) + ", " + GetFloorString( this->get(1,1) ) + ", " + GetFloorString( this->get(1,2) ) + "] / ";
	String row2 = "row2 [" + GetFloorString( this->get(2,0) ) + ", " + GetFloorString( this->get(2,1) ) + ", " + GetFloorString( this->get(2,2) ) + "] / ";
	return t + "Mat3:[" + row0 + row1 + row2 + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が完全に同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::equal( const Mat3T& other ) const{
	return this->Eigen::Matrix<T, 3, 3>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が許容範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::almostEqual( const Mat3T& other, T tolerance ) const{
	return
		this->getRowValue( 0 ).almostEqual( other.getRowValue( 0 ), tolerance ) &&
		this->getRowValue( 1 ).almostEqual( other.getRowValue( 1 ), tolerance ) &&
		this->getRowValue( 2 ).almostEqual( other.getRowValue( 2 ), tolerance ) ;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     zero matrixの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::isZero() const{
	return this->Eigen::Matrix<T, 3, 3>::operator==( Eigen::Matrix<T, 3, 3>::Zero( 3, 3 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     許容範囲内でzero matrixの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::almostZero( T tolerance ) const{
	Vec3 zeroVec3( T( 0.0 ) );
	return
		this->getRowValue( 0 ).almostEqual( zeroVec3, tolerance ) &&
		this->getRowValue( 1 ).almostEqual( zeroVec3, tolerance ) &&
		this->getRowValue( 2 ).almostEqual( zeroVec3, tolerance ) ;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位マトリックス（対角線座標の値＝１、その他＝０）にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setIdentity(){
	*this = Eigen::Matrix<T, 3, 3>::Identity( 3, 3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定した座標の値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setValue( u8 _row, u8 _col, T value ){
	assert( _row < 3 && _col < 3 );
	this->coeffRef( _row, _col ) = value;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全ての要素を同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setAllValue( T val ){
	*this = Eigen::Matrix<T, 3, 3>::Constant( 3, 3, val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Row値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setRowValues( const Vec3T<T>& row0, const Vec3T<T>& row1, const Vec3T<T>& row2 ){
	this->row( 0 ) = row0;
	this->row( 1 ) = row1;
	this->row( 2 ) = row2;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Col値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setColValues( const Vec3T<T>& col0, const Vec3T<T>& col1, const Vec3T<T>& col2 ){
	this->col( 0 ) = col0;
	this->col( 1 ) = col1;
	this->col( 2 ) = col2;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Axisを設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setAxis( const Vec3T<T> & x, const Vec3T<T> & y, const Vec3T<T> & z ){
	this->setColValues( x, y, z );
}


//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分を全て同じ値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setDiagonal( T val ){
	*this = Eigen::Matrix<T, 3, 3>::Zero( 3, 3 );
	this->operator()( 0, 0 ) = this->operator()( 1, 1 ) = this->operator()( 2, 2 ) = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分をVec4の値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setDiagonal( const Vec3T<T>& val ){
	*this = Eigen::Matrix<T, 3, 3>::Zero( 3, 3 );
	this->operator()( 0, 0 ) = val.x();
	this->operator()( 1, 1 ) = val.y();
	this->operator()( 2, 2 ) = val.z();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    方向とアップベクトルから回転を設定する (type=0の場合は direction=Z, upV=Y)
//!		@param[in] type 0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setFromDirectionAndUpvector( const Vec3T<T>& direction, const Vec3T<T>& upvector, u8 type, Bool dirNeg, Bool upVectorNeg ){
	Vec3T<T> zAxis, yAxis, xAxis;
	u8 axis_ = type <= 5 ? type : 0;
	switch ( axis_ ){
		case 0:
			zAxis = dirNeg ? direction.normal().negate() : direction.normal();
			yAxis = zAxis.cross( upvector.normal() ).cross( zAxis ).normal();
			yAxis = upVectorNeg ? yAxis.negate() : yAxis;
			xAxis = yAxis.cross( zAxis ).normal();
			break;
		case 1:
			zAxis = dirNeg ? direction.normal().negate() : direction.normal();
			xAxis = zAxis.cross( upvector.normal() ).cross( zAxis ).normal();
			xAxis = upVectorNeg ? xAxis.negate() : xAxis;
			yAxis = xAxis.cross( zAxis ).normal().negate();
			break;
		case 2:
			xAxis = dirNeg ? direction.normal().negate() : direction.normal();
			zAxis = xAxis.cross( upvector.normal() ).cross( xAxis ).normal();
			zAxis = upVectorNeg ? zAxis.negate() : zAxis;
			yAxis = zAxis.cross( xAxis ).normal();
			break;
		case 3:
			xAxis = dirNeg ? direction.normal().negate() : direction.normal();
			yAxis = xAxis.cross( upvector.normal() ).cross( xAxis ).normal();
			yAxis = upVectorNeg ? yAxis.negate() : yAxis;
			zAxis = yAxis.cross( xAxis ).normal().negate();
			break;
		case 4:
			yAxis = dirNeg ? direction.normal().negate() : direction.normal();
			xAxis = yAxis.cross( upvector.normal() ).cross( yAxis ).normal();
			xAxis = upVectorNeg ? xAxis.negate() : xAxis;
			zAxis = xAxis.cross( yAxis ).normal();
			break;
		case 5:
			yAxis = dirNeg ? direction.normal().negate() : direction.normal();
			zAxis = yAxis.cross( upvector.normal() ).cross( yAxis ).normal();
			zAxis = upVectorNeg ? zAxis.negate() : zAxis;
			xAxis = zAxis.cross( yAxis ).normal().negate();
			break;
	}
	this->setColValues( xAxis, yAxis, zAxis );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      スケールを設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setScaling( const Vec3T<T>& val ){
	Vec3T<T> col0 = this->getColValue( 0 );
	Vec3T<T> col1 = this->getColValue( 1 );
	Vec3T<T> col2 = this->getColValue( 2 );

	col0 *= ( val.x() / col0.length() );
	col1 *= ( val.y() / col1.length() );
	col2 *= ( val.z() / col2.length() );

	this->setColValues( col0, col1, col2 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Mat3T<T>::get( u8 row, u8 col ) const{
	return this->Eigen::Matrix<T, 3, 3>::coeff( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getRowValue( u8 rowIndex ) const{
	return Vec3T<T>( this->Eigen::Matrix<T, 3, 3>::row( rowIndex ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     colを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getColValue( u8 colIndex ) const{
	return Vec3T<T>( this->Eigen::Matrix<T, 3, 3>::col( colIndex ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      回転のX方向を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getXaxis() const{
	return this->getColValue( 0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      回転のY方向を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getYaxis() const{
	return this->getColValue( 1 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      回転のZ方向を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getZaxis() const{
	return this->getColValue( 2 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      回転値のみ（スケール値を省いた）のMat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::getRotationMat3()const{
	Vec3T<T> scalVec3 = this->getScaling();
	assert( scalVec3.almostZero() == false );
	Vec3T<T> invScale = scalVec3.inverse();

	Vec3T<T> row0{ this->get( 0, 0 ) * invScale.x(), this->get( 0, 1 ) * invScale.y(), this->get( 0, 2 ) * invScale.z() };
	Vec3T<T> row1{ this->get( 1, 0 ) * invScale.x(), this->get( 1, 1 ) * invScale.y(), this->get( 1, 2 ) * invScale.z() };
	Vec3T<T> row2{ this->get( 2, 0 ) * invScale.x(), this->get( 2, 1 ) * invScale.y(), this->get( 2, 2 ) * invScale.z() };
	return Mat3T<T> { row0, row1, row2 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      スケール値を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::getScaling()const{
	Vec3T<T> result;
	result.x() = std::sqrt( ( SQ( this->get( 0, 0 ) ) + SQ( this->get( 1, 0) ) + SQ( this->get( 2, 0) ) ) );
	result.y() = std::sqrt( ( SQ( this->get( 0, 1 ) ) + SQ( this->get( 1, 1) ) + SQ( this->get( 2, 1) ) ) );
	result.z() = std::sqrt( ( SQ( this->get( 0, 2 ) ) + SQ( this->get( 1, 2) ) + SQ( this->get( 2, 2) ) ) );

	if ( this->determinant() < T( 0.0 ) ){
		result.setNegate();
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::transpose() const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::transpose()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setTranspose(){
	*this = this->Eigen::Matrix<T, 3, 3>::transpose();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::inverse() const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::inverse()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::setInverse(){
	*this = this->Eigen::Matrix<T, 3, 3>::inverse();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    軸を変更する
//!	    @brief 軸を変更する
//!		@param[in] zyTo ZY軸をどの軸に変更するか 0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ（0の場合は変更なし、3の場合はZ→X,Y→Xへ変更）
//!		@param[in] dirNeg 1番目の軸を反転する（1番目＝ZYのZ）
//!		@param[in] upvNeg 2番目の軸を反転する（2番目＝ZYのY）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::axisChange( u8 zyTo, Bool dirNeg, Bool upvNeg ){
	Vec3T<T> xA = this->getColValue(0);
	Vec3T<T> yA = this->getColValue(1);
	Vec3T<T> zA = this->getColValue(2);

	if ( dirNeg == true && upvNeg == false ){
		zA *= -1.0;
		xA *= -1.0;
	}
	if ( dirNeg == false && upvNeg == true ){
		xA *= -1.0;
		yA *= -1.0;
	}
	if ( dirNeg == true && upvNeg == true ){
		zA *= -1.0;
		yA *= -1.0;
	}

	switch ( zyTo ){
		case 0: this->setColValues( xA, yA, zA );			break; //ZY
		case 1: this->setColValues( yA, xA * -1.0, zA );	break; //ZX
		case 2: this->setColValues( zA, xA, yA );			break; //XZ
		case 3: this->setColValues( zA, yA, xA * -1.0 );	break; //XY
		case 4: this->setColValues( yA, zA, xA );			break; //YX
		case 5: this->setColValues( xA * -1.0, zA, yA );	break; //YZ
		default: this->setColValues( xA, yA, zA );
	}
};

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::swapRows( u8 row1, u8 row2 ){
	this->Eigen::Matrix<T, 3, 3>::row( row1 ).swap( this->Eigen::Matrix<T, 3, 3>::row( row2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     col値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::swapCols( u8 col1, u8 col2 ){
	this->Eigen::Matrix<T, 3, 3>::col( col1 ).swap( this->Eigen::Matrix<T, 3, 3>::col( col2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     行列式を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Mat3T<T>::determinant() const{
	return T( this->Eigen::Matrix<T, 3, 3>::determinant() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T>& Mat3T<T>::operator = ( const Eigen::Matrix<T, 3, 3>& other ){
	this->Eigen::Matrix<T, 3, 3>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Mat3T<T>::operator()( u8 row, u8 col ){
	return this->Eigen::Matrix<T, 3, 3>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Mat3T<T>::operator()( u8 row, u8 col ) const{
	return this->Eigen::Matrix<T, 3, 3>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::operator == ( const Mat3T& other ) const{
	return this->Eigen::Matrix<T, 3, 3>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat3T<T>::operator != ( const Mat3T& other ) const{
	return this->Eigen::Matrix<T, 3, 3>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::operator + ( const Mat3T& other ) const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::operator+( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::operator += ( const Mat3T& other ){
	this->Eigen::Matrix<T, 3, 3>::operator+=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::operator - ( const Mat3T& other ) const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::operator-( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::operator -= ( const Mat3T& other ){
	this->Eigen::Matrix<T, 3, 3>::operator-=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::operator * ( const Mat3T& other ) const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::operator*( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat3T<T>::operator * ( const Vec3T<T>& vec3 ) const{
	return Vec3T<T>{this->Eigen::Matrix<T, 3, 3>::operator*( vec3 )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::operator * ( T val ) const{
	return Mat3T<T>{this->Eigen::Matrix<T, 3, 3>::operator*( val )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::operator *= ( const Mat3T& other ){
	this->Eigen::Matrix<T, 3, 3>::operator*=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::operator *= ( T val ){
	this->Eigen::Matrix<T, 3, 3>::operator*=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat3T<T>::operator / ( T val ) const{
	return this->Eigen::Matrix<T, 3, 3>::operator/( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat3T<T>::operator /= ( T val ){
	this->Eigen::Matrix<T, 3, 3>::operator/=( val );
}