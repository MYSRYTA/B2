namespace Burgess2MathFn {
	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		小さい方の値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	 T Min ( T val1, T val2 ) {
		return val1 > val2 ? val2 : val1;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		大きい方の値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	 T Max ( T val1, T val2 ) {
		return val1 < val2 ? val2 : val1;
	}
	 
	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		nim~maxの範囲内に収めた値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	 T Clamp ( T val, T min, T max ) {
		return ( val < min ? min : ( val > max ? max : val ) );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!		inValをinMin-inMaxの範囲からoutMin-outMaxの範囲へリスケールした値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T Rescale ( T inVal, T inMin, T inMax, T outMin, T outMax ) {
		return outMin + ( outMax - outMin ) * ( inVal - inMin ) / ( inMax - inMin );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてfloat AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T Lerp ( T valA, T valB, T t ) {
		return valA + ( ( valB - valA ) * t );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   t値(0.0~1.0)に基づいてfloat AとBを線形補間した値を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T LinearInterpolate ( T valA, T valB, T t ) {
		return Lerp<T> ( valA, valB, t );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   min~max範囲内におけるvalのt値(0.0~1.0)を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T ReverseLerp ( T val, T minVal, T maxVal ) {
		return ( ( val - minVal ) / ( maxVal - minVal ) );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   ２分木探索  tree(昇順)に対してkeyが所属する配列番号を返す　例：(tree=[0,5,7,13], key=10) return=2, remainder=3
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	s32 BinarySearchTree( const std::vector<T>& tree, T key, T& remainder ){
		T lowID = 1;
		T highID = T( tree.size() );
		/* テーブル内を2分割しながら検索 */
		while ( lowID < highID ){
			T midID = ( lowID + highID ) / 2;
			if ( tree[midID] <= key ){
				lowID = midID + 1;
			} else{
				highID = midID;
			}
		}
		remainder = T( key - tree[lowID - 1] );
		return lowID - 1;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   ２分木探索  tree(昇順)に対してkeyが所属する配列番号を返す　例：(tree=[0,5,7,13], key=10) return=2
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	s32 BinarySearchTree( const std::vector<T>& tree, T key ){
		T dummy;
		return BinarySearchTree( tree, key, dummy );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	std::vector<T> FillInterpolated( T a, T b, u32 count, Bool popFirst, Bool popLast ){
		u32 size = count;
		if ( popFirst ){ size -= 1; }
		if ( popLast ){ size -= 1; }
		std::vector<T> result( size );
		u32 o = popFirst ? 1 : 0;
		T e = T( 1.0 ) / T( size );
		for ( u32 i = o; i < size; i++ ){
			T ratio = e * i;
			result[i - o] = ( T( 1.0 ) - ratio ) * a + ratio * b;
		}
		return result;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   2つの値が誤差範囲内で同じであればtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	Bool AlmostEqual ( T valA, T valB, T tolerance ) {
		return std::abs ( valA - valB ) < tolerance;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が限りなく0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	Bool IsZero ( T val ) {
		return -BURGESS2::TOLERANCE < val&& val < BURGESS2::TOLERANCE;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   値が誤差範囲内で0に近い場合はtrueを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	Bool AlmostZero ( T val, T tolerance ) {
		return val < tolerance && val > -tolerance;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   float配列を昇順(降順)でソートする。元の配列番号をarrayOrigIDに返す
	//!		@param[in, out] arrayVal ソート対象となる配列
	//!		@param[out] arrayOrigID ソート前の配列番号
	//!		@param[in] descendingOrder true=降順
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	void Sort ( IO std::vector<T> &arrayVal, OUT std::vector<u32> &arrayOrigID, Bool descendingOrder ) {
		s32 cnt = s32(arrayVal.size ());
		if ( cnt == 0 ) { return; }
		
		arrayOrigID.resize ( cnt );

		std::vector<std::vector<T>> val_id ( cnt );
		#pragma omp parallel for if(1000 < cnt)
		for ( s32 i = 0; i < cnt; i++ ) {
			val_id[i].resize ( 2 );
			val_id[i][0] = arrayVal[i];
			val_id[i][1] = T(i);
		}
		std::sort ( val_id.begin (), val_id.end () );

		if ( descendingOrder ) {
			#pragma omp parallel for if(1000 < cnt)
			for ( s32 i = 0; i < cnt; i++ ) {
				u32 ii = cnt - i - 1;
				arrayVal[i] = val_id[ii][0];
				arrayOrigID[i] = u32 ( val_id[ii][1] );
			}
		} else {
			#pragma omp parallel for if(1000 < cnt)
			for ( s32 i = 0; i < cnt; i++ ) {
				arrayVal[i] = val_id[i][0];
				arrayOrigID[i] = u32 ( val_id[i][1] );
			}
		}
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   float配列を昇順(降順)でソートする。
	//!		@param[in, out] arrayVal ソート対象となる配列
	//!		@param[in] descendingOrder true=降順
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	void Sort ( IO std::vector<T> &arrayVal, Bool descendingOrder ) {
		std::vector<u32> dummy;
		Burgess2MathFn::Sort<T> ( arrayVal, dummy, descendingOrder );
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最低値の配列要素を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T Minimum ( const std::vector<T> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		T smallest = arrayVal [0];
		s32 loopCnt = s32(arrayVal.size ());
		if ( loopCnt < 1000 ) {
			for ( u32 i = 1; i < arrayVal.size (); i++ ) {
				if ( arrayVal [i] < smallest ) {
					smallest = arrayVal [i];
				}
			}
		} else {
			{
				T min = std::numeric_limits<T>::max ();
				s32 valCnt = s32(arrayVal.size ());
				#pragma omp for nowait
				for ( s32 ii = 0; ii<valCnt; ++ii ) {
					min = Burgess2MathFn::Min ( arrayVal [ii], min );
				}
				#pragma omp critical 
				{
					smallest = Burgess2MathFn::Min ( smallest, min );
				}
			}
		}
		return smallest;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最大値の配列要素を返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T Maximum ( const std::vector<T> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		T biggest = arrayVal [0];
		for ( u32 i = 1; i < arrayVal.size (); i++ ) {
			if ( biggest < arrayVal [i] ) {
				biggest = arrayVal [i];
			}
		}
		return biggest;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最低値の配列要素のIndexを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	u32 MinimumIndex ( const std::vector<T> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		T smallest = arrayVal [0];
		u32 result = 0;
		s32 loopCnt = s32(arrayVal.size ());
		for ( s32 i = 1; i < loopCnt; i++ ) {
			if ( arrayVal [i] < smallest ) {
				smallest = arrayVal [i];
				result = i;
			}
		}
		return result;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   最大値の配列要素のIndexを返す
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	u32 MaximumIndex ( const std::vector<T> &arrayVal ) {
		if ( arrayVal.size () == 0 ) { return -1; }
		T biggest = arrayVal [0];
		u32 result = 0;
		for ( u32 i = 1; i < arrayVal.size (); i++ ) {
			if ( biggest < arrayVal [i] ) {
				biggest = arrayVal [i];
				result = i;
			}
		}
		return result;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   radian値をdegree値へ変換する
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T RadToDeg ( T rad ) { return rad * T(BURGESS2::RAD); }

	//------------------------------------------------------------------------------------------------------------------------------------------------
	//!	   degree値をradian値へ変換する
	//------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T>
	T DegToRad ( T deg ) { return deg * T(BURGESS2::PI_DIV_180); }

}