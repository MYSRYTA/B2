//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T() : Eigen::Vector<T, 3>{ Eigen::Vector<T, 3>::Zero( 3 ) }
{ *this = Eigen::Vector<T, 3>::Zero( 3 ); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T( T val ) : Eigen::Vector<T, 3>( Eigen::Vector<T, 3>::Constant( val ) )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T( T _x, T _y, T _z ) : Eigen::Vector<T, 3>(){
	*this << _x, _y, _z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T( const VecT<T>& val ) : Eigen::Vector<T, 3>() {
	if(val.size()<3){ 
		*this = Eigen::Vector<T, 3>::Zero( 3 );
	} else{
		*this << val[0], val[1], val[2];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T( const std::vector<T>& val ) : Eigen::Vector<T, 3>() {
	if ( val.size() < 3 ){
		*this = Eigen::Vector<T, 3>::Zero( 3 );
	} else{
		*this << val[0], val[1], val[2];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>::Vec3T( const Eigen::Vector<T, 3>& other ) : Eigen::Vector<T, 3>( other )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [0]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec3T<T>::x(){ return this->Eigen::Vector<T, 3>::x(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [0]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec3T<T>::x()const{ return this->Eigen::Vector<T, 3>::x(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [1]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec3T<T>::y(){ return this->Eigen::Vector<T, 3>::y(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [1]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec3T<T>::y()const{ return this->Eigen::Vector<T, 3>::y(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [2]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec3T<T>::z(){ return this->Eigen::Vector<T, 3>::z(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     [2]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec3T<T>::z()const{ return this->Eigen::Vector<T, 3>::z(); }

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Vec3T<T>::toVec() const{
	return VecT<T> { std::vector<T>{this->x(), this->y(), this->z()} };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Vec3T<T>::toTypeArray() const{
	return std::vector<T>{this->x(), this->y(), this->z()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Vec3T<T>::toString( const String title ) const{
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	return t + "Vec3:[" + GetFloorString( this->x() ) + ", " + GetFloorString( this->y() ) + ", " + GetFloorString( this->z() ) + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::equal( const Vec3T& other ) const{
	return ( this->x() == other.x() ) && ( this->y() == other.y() ) && ( this->z() == other.z() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostEqual( const Vec3T& other, T tolerance ) const{
	return	( std::abs( this->x() - other.x() ) < tolerance ) &&
			( std::abs( this->y() - other.y() ) < tolerance ) &&
			( std::abs( this->z() - other.z() ) < tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ゼロベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::isZero() const{
	return this->x() == T( 0.0 ) && this->y() == T( 0.0 ) && this->z() == T( 0.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値が誤差範囲内でゼロベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostZero( T tolerance ) const{
	return this->almostEqual( Vec3T<T>(T(0.0)), tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    2つのベクトルが完全に並行の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::parallel( const Vec3T& other ) const{
	T dot{ 0.0 };
	if ( this->isUnit() && other.isUnit() ){
		dot = this->dot( other );
	} else{
		dot = this->normal().dot( other.normal() );
	}
	
	return dot == T( -1.0 ) || dot == T( 1.0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが誤差範囲内で並行の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostParallel( const Vec3T& other, T tolerance ) const{
	T dot{ 0.0 };
	if ( this->isUnit() && other.isUnit() ){
		dot = this->dot( other );
	} else{
		dot = this->normal().dot( other.normal() );
	}
	return Burgess2MathFn::AlmostEqual( dot, T( -1.0 ), tolerance ) || Burgess2MathFn::AlmostEqual( dot, T( 1.0 ), tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが完全に同方向の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::sameDirection( const Vec3T& other ) const{
	if ( this->isZero() || other.isZero() ){ return false; }
	
	if ( this->equal( other ) ){ return true; }
	
	if ( this->isUnit() && other.isUnit() ){
		return this->angleTo( other ) == T( 0.0 );
	} else{
		return this->unit().angleTo( other.unit() ) == T( 0.0 );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルが誤差範囲内で同方向の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostSameDirection( const Vec3T& other, T tolerance ) const{
	if ( this->almostZero( tolerance ) || other.almostZero( tolerance ) ){ return false; }

	if ( this->almostEqual( other, tolerance ) ){ return true; }

	if ( this->almostUnit( tolerance ) && other.almostUnit( tolerance ) ){
		return this->angleTo( other ) < tolerance;
	} else{
		return this->unit().angleTo( other.unit() ) < tolerance;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::isUnit() const{
	return this->lengthSquared() == T(1.0);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     誤差範囲内で単位ベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::almostUnit( T tolerance ) const{
	return Burgess2MathFn::AlmostEqual( this->lengthSquared(), T( 1.0 ), tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .zごとに最小値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::getMin( const Vec3T& other ) const{
	return Vec3T{ Burgess2MathFn::Min( this->x(), other.x() ), Burgess2MathFn::Min( this->y(), other.y() ), Burgess2MathFn::Min( this->z(), other.z() ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!		.x .y .zごとに最大値で構成したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::getMax( const Vec3T& other ) const{
	return Vec3T{ Burgess2MathFn::Max( this->x(), other.x() ), Burgess2MathFn::Max( this->y(), other.y() ), Burgess2MathFn::Max( this->z(), other.z() ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x .y .zごとにlimitの範囲に制限したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::clamp( const Vec3T& limitVal0, const Vec3T& limitVal1 ) const{
	Vec3T min = limitVal0.getMin( limitVal1 );
	Vec3T max = limitVal0.getMax( limitVal1 );
	return	Vec3T<T> { Burgess2MathFn::Clamp( this->x(), min.x(), max.x() ), 
						Burgess2MathFn::Clamp( this->y(), min.y(), max.y() ), 
						Burgess2MathFn::Clamp( this->z(), min.z(), max.z() ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::lerp( const Vec3T& other, T t ) const{
	return *this + ( ( other - *this ) * t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと球面補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::slerp( const Vec3T& other, T t ) const{
	if ( this->almostEqual( other ) ){ return *this; }

	Vec3T<T> v = Burgess2MathFn::AlmostEqual( this->lengthSquared(), T( 1.0 ) ) ? *this : this->unit();
	Vec3T<T> o = Burgess2MathFn::AlmostEqual( other.lengthSquared(), T( 1.0 ) ) ? other : other.unit();
	T d = v.dot( o );
	if ( Burgess2MathFn::AlmostEqual( d, T( 1.0 ) ) ){ return *this; }

	T angle = std::acos( d );
	T sinTh = std::sin( angle );

	T s = std::sin( angle * ( T( 1.0 ) - t ) );
	T e = std::sin( angle * t );
	Vec3T<T> r = ( ( s * v ) + ( e * o ) ) / sinTh;
	return r.unit();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::linearInterpolate( const Vec3T& other, T t ) const{
	return this->lerp( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと球面補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::sphericalLinearInterpolate( const Vec3T& other, T t ) const{
	return this->slerp( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さの2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::lengthSquared() const{
	return this->Eigen::Vector<T, 3>::squaredNorm();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.lengthSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::length() const{
	return this->Eigen::Vector<T, 3>::norm();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さの2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::magnitudeSquared() const{
	return this->lengthSquared();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.magnitudeSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::magnitude() const{
	return this->length();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::normal() const{
	if ( this->isZero() ){ return *this; }

	return this->Eigen::Vector<T, 3>::normalized();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setNormal(){
	if ( this->isZero() ){ return; }
	
	this->Eigen::Vector<T, 3>::normalize();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::unit() const{
	return this->normal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setUnit(){
	this->setNormal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     反転ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::negate() const{
	return Vec3T{ -this->x(), -this->y(), -this->z() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     反転ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setNegate(){
	*this = this->negate();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::inverse() const{
	if ( this->isZero() ){ return Vec3T<T>(); }

	return Vec3T{ T( 1.0 ) / this->x(), T( 1.0 ) / this->y(), T( 1.0 ) / this->z() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setInverse(){
	*this = this->inverse();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    反射ベクトルを返す
//!	    @brief	反射ベクトルを返す
//!		@param[in] normal 反射面の法線 (単位ベクトル)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::reflect( const Vec3T& normal ) const{
	return *this - normal * T( 2.0 ) * this->dot( normal );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    反射ベクトルにする
//!	    @brief	反射ベクトルを返す
//!		@param[in] normal 反射面の法線 (単位ベクトル)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::setReflect( const Vec3T& normal ){
	*this = this->reflect( normal );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    指定した角度で制限をかけたベクトルを返す
//!	    @brief	指定した角度で制限をかけたベクトルを返す
//!		@param[in] baseDir 基準となるベクトル
//!		@param[in] limitAngle 制限角度(ラジアン値)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::angleLimited( const Vec3T<T>& baseDir, T limitAngle )const{
	if ( baseDir.angleTo( *this ) < limitAngle ){
		return *this;
	} else{
		Vec3T<T> c = baseDir.cross( *this );
		QuatT<T> q;
		q.setFromDirectionAndUpvector( c, baseDir );
		Rad3T<T> d( T( 0.0 ), T( 0.0 ), limitAngle );
		QuatT<T> q2 = q.addAngle( d );
		return q2.getYaxis() * this->length();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::dot( const Vec3T& other ) const{
	return this->Eigen::Vector<T, 3>::dot( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     外積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::cross( const Vec3T& other ) const{
	return this->Eigen::Vector<T, 3>::cross( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの位置ベクトルの距離を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::distanceTo( const Vec3T& other ) const{
	if ( this->almostEqual( other ) ){ return T( 0.0 ); }

	Vec3T<T> d = *this - other;
	return d.length();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つの位置ベクトルの距離が指定した値未満の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::distanceLessThan( const Vec3T& other, T dist ) const{
	Vec3T<T> d = *this - other;
	return d.length() < dist;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの間の角度(ラジアン単位)を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Vec3T<T>::angleTo( const Vec3T& other ) const{
	T dot{ 0.0 };
	if ( this->isUnit() && other.isUnit() ){
		dot = Burgess2MathFn::Clamp( this->dot( other ), T( -1.0 ), T( 1.0 ) );
	} else{
		dot = Burgess2MathFn::Clamp( this->unit().dot( other.unit() ), T( -1.0 ), T( 1.0 ) );
	}

	if ( dot == T( 1.0 ) ){
		return T( 0.0 );
	} else{
		return std::acos( dot );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::rotate( const QuatT<T>& rot ) const{
	return rot.rotateVector( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
/*template <typename T>
Vec3T<T> Vec3T<T>::rotate( const Rad3T<T>& rot ) const{
	return rot.rotatVector( *this );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::rotate( const Deg3T<T>& rot ) const{
	return rot.rotatVector( *this );
}*/

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     このベクトルから対象ベクトルまでの回転量を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
/// QuaternionAxisToAxis_C
template <typename T>
QuatT<T> Vec3T<T>::rotateTo( const Vec3T<T>& other ) const{
	QuatT<T> result;
	result.setFrom2Vector( *this, other );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T>& Vec3T<T>::operator = ( const Eigen::Vector<T, 3>& other ){
	this->Eigen::Vector<T, 3>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Vec3T<T>::operator[]( u8 id ){
	return this->Eigen::Vector<T, 3>::operator[]( id );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Vec3T<T>::operator[]( u8 id )const{
	return this->Eigen::Vector<T, 3>::operator[]( id );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::operator == ( const Vec3T& other ) const{
	return this->Eigen::Vector<T, 3>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Vec3T<T>::operator != ( const Vec3T& other ) const{
	return this->Eigen::Vector<T, 3>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator+( const Vec3T& other )const{
	return Vec3T<T>{this->Eigen::Vector<T, 3>::operator+( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator+=( const Vec3T& other ){
	this->Eigen::Vector<T, 3>::operator+=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator-( const Vec3T& other )const{
	return Vec3T<T>{this->Eigen::Vector<T, 3>::operator-( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator-=( const Vec3T& other ){
	this->Eigen::Vector<T, 3>::operator-=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator*( const T val ) const{
	return Vec3T{ this->Eigen::Vector<T, 3>::operator*( val ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator*( const Vec3T& other ) const{
	return Vec3T{ this->x() * other.x(), this->y() * other.y(), this->z() * other.z() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator*=( const T val ){
	this->Eigen::Vector<T, 3>::operator*=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator*=( const Vec3T& other ){
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator/( const T val ) const{
	T e = T( 1.0 ) / val;
	return this->operator*( e );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Vec3T<T>::operator/( const Vec3T& other ) const{
	return Vec3T<T> { this->x() / other.x(), this->y() / other.y(), this->z() / other.z() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator/=( const T val ){
	this->Eigen::Vector<T, 3>::operator/=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Vec3T<T>::operator/=( const Vec3T& other ){
	*this = *this / other;
}
