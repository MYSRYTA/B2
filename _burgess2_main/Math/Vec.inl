//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT() : Eigen::Vector<T, Eigen::Dynamic>{ Eigen::Vector<T, Eigen::Dynamic>::Zero( 1 ) }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT( s32 size ) : Eigen::Vector<T, Eigen::Dynamic>{ Eigen::Vector<T, Eigen::Dynamic>::Zero( size ) }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT( s32 size, T val ) : Eigen::Vector<T, Eigen::Dynamic>( size ){
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < s32(size); ++i ){ this->coeffRef( i ) = val; }
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT( const VecT<T>& val ) : Eigen::Vector<T, Eigen::Dynamic>( val )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT( std::vector<T>& val ){
	if ( val.size() == 0 ){
		*this = Eigen::Vector<T, Eigen::Dynamic>::Zero( 1 );
	} else{
		*this = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &val[0], val.size() );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>::VecT( Eigen::Vector<T, Eigen::Dynamic>& other ) : Eigen::Vector<T, Eigen::Dynamic>( other )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列要素数を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
s32 VecT<T>::size()const{
	return u32(this->Eigen::Vector<T, Eigen::Dynamic>::size());
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列要素数を変更する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::resize( s32 newSize ) {
	this->Eigen::Vector<T, Eigen::Dynamic>::conservativeResize( newSize );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ゼロベクターにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::setZero( ){
	if ( this->size() == 0 ){
		*this = Eigen::Vector<T, Eigen::Dynamic>::Zero( 1 );
	} else{
		*this = Eigen::Vector<T, Eigen::Dynamic>::Zero( this->size() );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素をセットする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::set( s32 id, T val ){
	assert( id < this->size() );
	this->Eigen::Vector<T, Eigen::Dynamic>::coeffRef(id) = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全要素を同一の値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::setAll( T val ){
	for ( s32 i = 0; i < this->size(); ++i ){ this->coeffRef( i ) = val; }
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を挿入する (複数回実行する場合はstd::vectorで処理を行った後にVecにキャストする方が良い）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::insert( s32 id, T val ){
	std::vector<T> stdVec( &this->operator[](0), this->data() + this->cols() * this->rows() );

	stdVec.insert( stdVec.begin() + id, val );

	*this = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &stdVec[0], stdVec.size() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecを連結する (複数回実行する場合はstd::vectorで処理を行った後にVecにキャストする方が良い）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::combine( const VecT& other ){
	std::vector<T> thisVec( &this->operator[]( 0 ), this->data() + this->cols() * this->rows() );
	std::vector<T> otherVec( &other[0], other.data() + other.cols() * other.rows() );

	if ( thisVec.size() < otherVec.size() ){
		thisVec.reserve( thisVec.size() + otherVec.size() );
	}
	std::copy( otherVec.begin(), otherVec.end(), std::back_inserter( thisVec ) );

	*this = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &thisVec[0], thisVec.size() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列の先頭に要素を追加する (複数回実行する場合はstd::vectorで処理を行った後にVecにキャストする方が良い）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::push_top( T val ){
	this->insert( 0, val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列の末尾に要素を追加する (複数回実行する場合はstd::vectorで処理を行った後にVecにキャストする方が良い）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::push_back( T val ){
	std::vector<T> thisVec( &this->operator[]( 0 ), this->data() + this->cols() * this->rows() );

	thisVec.insert( std::end( thisVec ), val );
	*this = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &thisVec[0], thisVec.size() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::get( s32 id ) const{
	assert( id < this->size() );
	return this->coeffRef(id);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全ての配列要素をstd::vecotorで取得する (toTypeArray()と同じ)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> VecT<T>::getValues() const{
	return std::vector<T>( &this->operator[]( 0 ), this->data() + this->cols() * this->rows() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する (getValues()と同じ)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> VecT<T>::toTypeArray() const{
	return std::vector<T>( &this->operator[]( 0 ), this->data() + this->cols() * this->rows() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String VecT<T>::toString( const String title ) const{
	String s = "Vec :size=" + std::to_string( this->size() ) + ", [";
	for ( u32 i = 0; i < this->size() - 1; i++ ){
		s += GetFloorString( this->get( i ) ) + ", ";
	}
	s += GetFloorString( this->get( this->size() - 1 ) ) + "]";
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	return t + s;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を削除する (複数回実行する場合はstd::vectorで処理を行った後にVecにキャストする方が良い）
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::remove( s32 id ){
	assert( id < this->size() );
	if ( id == 0 ){
		return this->pop_top();
	} else if ( id == this->size() - 1 ){
		return this->pop_back();
	} else{
		T val = this->get( id );
	
		std::vector<T> thisVec( &this->operator[]( 0 ), this->data() + this->cols() * this->rows() );
		thisVec.erase( thisVec.begin() + id);
		*this = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &thisVec[0], thisVec.size() );
	
		return val;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列の先頭を削除する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::pop_top(){
	assert( this->size() != 0 );
	T val = this->get( 0 );
	*this = this->Eigen::Vector<T, Eigen::Dynamic>::tail( this->size() - 1 );
	return val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列の末尾を削除する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::pop_back(){
	assert( this->size() != 0 );
	T val = this->get( this->size()-1 );
	*this = this->Eigen::Vector<T, Eigen::Dynamic>::head( this->size() - 1 );
	return val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::equal( const VecT& other ) const{
	if ( this->size() != other.size() ||
		 this->size() == 0 ||
		 other.size() == 0 ){ 
		return false; 
	}
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		if ( this->operator[]( i ) != other[i] ){
			return false;
		}
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのベクトルの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::almostEqual( const VecT& other, T tolerance ) const{
	if ( this->size() != other.size() ||
		 this->size() == 0u ||
		 other.size() == 0u ){
		return false;
	}
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		if ( tolerance <= std::abs( this->operator[]( i ) - other[i] ) ){
			return false;
		}
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ゼロベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::isZero() const{
	if ( this->size() == 0 ){ return false; }

	Bool result = true;
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		if ( this->operator[]( i ) != T( 0.0 ) ){
			result = false;
			break;
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値が誤差範囲内でゼロベクトルの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::almostZero( T tolerance ) const{
	if ( this->size() == 0 ){ return false; }

	Bool result = true;
	for ( s32 i = 0; i < this->size(); ++i ){
		if ( Burgess2MathFn::AlmostZero( this->operator[]( i ), tolerance) == false ){
			result = false;
			break;
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     最小値の配列要素を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::minimum( OUT s32& id ) const{
	if ( this->size() == 0 ){ return T( -1.0 ); }

	T result = this->minimum();
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		if ( result == this->operator[]( i ) ){
			id = i;
			break;
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     最小値の配列要素を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::minimum() const{
	if ( this->size() == 0 ){ return T( -1.0 ); }
	return this->Eigen::Vector<T, Eigen::Dynamic>::minCoeff();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     最大値の配列要素を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::maximum( OUT s32& id ) const{
	if ( this->size() == 0 ){ return T( -1.0 ); }
	
	T result = this->maximum();
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		if ( result == this->operator[]( i ) ){
			id = i;
			break;
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     最大値の配列要素を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::maximum() const{
	if ( this->size() == 0 ){ return T( -1.0 ); }
	return this->Eigen::Vector<T, Eigen::Dynamic>::maxCoeff();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::lerp( const VecT& other, T t ) const{
	s32 c = Burgess2MathFn::Min( this->size(), other.size() );
	VecT<T> result( c );
	if ( c == 0 ){ return result; }
	
	for ( s32 i = 0; i < c; ++i ){
		result[i] = Burgess2MathFn::Lerp( this->operator[]( i ), other[i], t );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象ベクトルと線形補間したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::linearInterpolate( const VecT& other, T t ) const{
	return this->lerp( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さの2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::lengthSquared() const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::squaredNorm();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.lengthSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::length() const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::norm();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さの2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::magnitudeSquared() const{
	return this->lengthSquared();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルの長さを返す (比較のために長さを取得するのであれば.magnitudeSquared()の値を用いる方が軽量)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::magnitude() const{
	return this->length();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::normal() const{
	if ( this->isZero() ){ return *this; }
	T l = this->length();

	VecT<T> result( u32(this->size()) );
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->operator[]( i ) / l;
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::setNormal(){
	if ( this->isZero() ){ return; }

	*this = this->normal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::unit() const{
	return this->normal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::setUnit(){
	this->setNormal();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T VecT<T>::dot( const VecT& other ) const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::dot( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T>& VecT<T>::operator = ( const Eigen::Vector<T, Eigen::Dynamic>& other ){
	this->Eigen::Vector<T, Eigen::Dynamic>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& VecT<T>::operator[]( s32 id ){
	return this->Eigen::Vector<T, Eigen::Dynamic>::operator[]( id );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& VecT<T>::operator[]( s32 id )const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::operator[]( id );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::operator == ( const VecT& other ) const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool VecT<T>::operator != ( const VecT& other ) const{
	return this->Eigen::Vector<T, Eigen::Dynamic>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator+( const VecT& other )const{
	s32 size = s32(Burgess2MathFn::Min( this->size(), other.size() ));
	VecT result( size );
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) + other.get( i );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator+=( const VecT& other ){
	this->Eigen::Vector<T, Eigen::Dynamic>::operator+=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator-( const VecT& other )const{
	s32 size = Burgess2MathFn::Min( this->size(), other.size() );
	VecT result( size );
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) - other.get( i );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator-=( const VecT& other ){
	this->Eigen::Vector<T, Eigen::Dynamic>::operator-=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator*( const T& val )const{
	VecT<T> result( this->size() );
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) * val;
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator*( const VecT& other ) const{
	s32 size = Burgess2MathFn::Min( this->size(), other.size() );
	VecT result( size );
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) * other.get( i );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator*=( const T& val ){
	this->Eigen::Vector<T, Eigen::Dynamic>::operator*=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator*=( const VecT& other ){
	s32 size = Burgess2MathFn::Min( this->size(), other.size() );
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		this->operator[]( i ) = this->get( i ) * other.get( i );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator/( const T& val )const{
	VecT<T> result( this->size() );
	s32 size = this->size();
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) / val;
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> VecT<T>::operator/( const VecT& other ) const{
	s32 size = Burgess2MathFn::Min( this->size(), other.size() );
	VecT result( size );
	for ( s32 i = 0; i < size; ++i ){
		result[i] = this->get( i ) / other.get( i );
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator/=( const T& val ){
	this->Eigen::Vector<T, Eigen::Dynamic>::operator/=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void VecT<T>::operator/=( const VecT& other ){
	s32 size = Burgess2MathFn::Min( this->size(), other.size() );
	#pragma omp parallel for if(1000 < size)
	for ( s32 i = 0; i < size; ++i ){
		this->operator[]( i ) = this->get( i ) / other.get( i );
	}
}