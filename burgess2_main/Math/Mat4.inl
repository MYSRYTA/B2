//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T() : Eigen::Matrix<T, 4, 4>( Eigen::Matrix<T, 4, 4>::Identity( 4, 4 ) )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//!		@param[in] _00_33 引数の順はrow-major　[row=0,col=0][row=0,col=1][row=0,col=2][row=0,col=3][row=1,col=0]...  
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( T _00, T _01, T _02, T _03, T _10, T _11, T _12, T _13, T _20, T _21, T _22, T _23, T _30, T _31, T _32, T _33 ) : Eigen::Matrix<T, 4, 4>(){
	*this << _00, _01, _02, _03, _10, _11, _12, _13, _20, _21, _22, _23, _30, _31, _32, _33;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( const Vec4T<T>& _row0, const Vec4T<T>& _row1, const Vec4T<T>& _row2, const Vec4T<T>& _row3 ) : Eigen::Matrix<T, 4, 4>(){
	*this <<	_row0[0], _row0[1], _row0[2], _row0[3],
				_row1[0], _row1[1], _row1[2], _row1[3],
				_row2[0], _row2[1], _row2[2], _row2[3],
				_row3[0], _row3[1], _row3[2], _row3[3];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//!		@param[in] data 
//!		@param[in] columnMajorData 第一引数の"data"の値順がcol-majorの場合はtrue
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( const VecT<T>& data, Bool columnMajorData ) : Eigen::Matrix<T, 4, 4>() {
	if( data.size() < 16 ){ 
		this->Eigen::Matrix<T, 4, 4>::Identity( 4, 4 );
		return;
	}

	if(columnMajorData){
		*this = Eigen::Map<Eigen::Matrix<T, 4, 4>>( data.toTypeArray().data() );
	} else{
		*this << data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//!		@param[in] data 
//!		@param[in] columnMajorData 第一引数の"data"の値順がcol-majorの場合はtrue
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( std::vector<T>& data, Bool columnMajorData ) : Eigen::Matrix<T, 4, 4>(){
	if (data.size() < 16 ){
		this->Eigen::Matrix<T, 4, 4>::Identity( 4, 4 ); 
		return;
	}

	if(columnMajorData){
		*this = Eigen::Map<Eigen::Matrix<T, 4, 4>>( data.data() );
	} else{
		*this << data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( const XfoT<T>& xfo ): Eigen::Matrix<T, 4, 4>(){
	*this = xfo.toMat4();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( const SRTT<T>& srt ): Eigen::Matrix<T, 4, 4>(){
	*this = srt.toMat4();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T( const Eigen::Matrix<T, 4, 4>& other ) : Eigen::Matrix<T, 4, 4>( other )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Mat4T<T>::toVec( Bool toColumnMajorVal ) const{
	return VecT<T>( this->toTypeArray( toColumnMajorVal ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列に変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Mat4T<T>::toTypeArray( Bool toColumnMajorVal )const{
	std::vector<T> stdVec( 16 );
	if( toColumnMajorVal ){
		Eigen::Map<Eigen::Matrix<T, 4, 4>>( stdVec.data(), 4, 4 ) = *this;
	} else{
		stdVec = std::vector<T>{ this->get( 0, 0 ), this->get( 0, 1 ), this->get( 0, 2 ), this->get( 0, 3 ),
								this->get( 1, 0 ), this->get( 1, 1 ), this->get( 1, 2 ), this->get( 1, 3 ),
								this->get( 2, 0 ), this->get( 2, 1 ), this->get( 2, 2 ), this->get( 2, 3 ),
								this->get( 3, 0 ), this->get( 3, 1 ), this->get( 3, 2 ), this->get( 3, 3 ), };
	}
	return stdVec;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Xfoに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
XfoT<T> Mat4T<T>::toXfo()const{
	return XfoT<T> { this->getScaling(), this->getRotation(), this->getTranslation() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     SRTに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> Mat4T<T>::toSRT( const BURGESS2::RotationOrder order )const{
	return SRTT<T> { this->getScaling(), Deg3T<T>{ this->getRotation(), order }, this->getTranslation() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Mat4T<T>::toString( const String title ) const{
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	String row0 = "row0 [" + GetFloorString( this->get(0, 0) ) + ", " + GetFloorString( this->get(0, 1) ) + ", " + GetFloorString( this->get(0, 2) ) + ", " + GetFloorString( this->get(0, 3) ) + "] / ";
	String row1 = "row1 [" + GetFloorString( this->get(1, 0) ) + ", " + GetFloorString( this->get(1, 1) ) + ", " + GetFloorString( this->get(1, 2) ) + ", " + GetFloorString( this->get(1, 3) ) + "] / ";
	String row2 = "row2 [" + GetFloorString( this->get(2, 0) ) + ", " + GetFloorString( this->get(2, 1) ) + ", " + GetFloorString( this->get(2, 2) ) + ", " + GetFloorString( this->get(2, 3) ) + "] / ";
	String row3 = "row3 [" + GetFloorString( this->get(3, 0) ) + ", " + GetFloorString( this->get(3, 1) ) + ", " + GetFloorString( this->get(3, 2) ) + ", " + GetFloorString( this->get(3, 3) ) + "]";
	return t + "Mat4:[" + row0 + row1 + row2 + row3 + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が完全に同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::equal( const Mat4T& other ) const{
	return this->Eigen::Matrix<T, 4, 4>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が許容範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::almostEqual( const Mat4T& other, T tolerance ) const{
	return
		this->getRowValue(0).almostEqual( other.getRowValue(0), tolerance ) &&
		this->getRowValue(1).almostEqual( other.getRowValue(1), tolerance ) &&
		this->getRowValue(2).almostEqual( other.getRowValue(2), tolerance ) &&
		this->getRowValue(3).almostEqual( other.getRowValue(3), tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     zero matrixの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::isZero() const{
	return this->Eigen::Matrix<T, 4, 4>::operator==( Eigen::Matrix<T, 4, 4>::Zero( 4, 4 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     許容範囲内でzero matrixの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::almostZero( T tolerance ) const{
	Vec4T<T> zeroVec4( T( 0.0 ) );
	return
		this->getRowValue(0).almostEqual( zeroVec4, tolerance ) &&
		this->getRowValue(1).almostEqual( zeroVec4, tolerance ) &&
		this->getRowValue(2).almostEqual( zeroVec4, tolerance ) &&
		this->getRowValue(3).almostEqual( zeroVec4, tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位マトリックス（対角線座標の値＝１、その他＝０）にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setIdentity(){
	*this = Eigen::Matrix<T, 4, 4>::Identity( 4, 4 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定した座標の値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setValue( u8 _row, u8 _col, T value ){
	assert( _row < 4 && _col < 4 );
	this->coeffRef(_row, _col) = value;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全ての要素を同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setAllValue( T val ){
	*this = Eigen::Matrix<T, 4, 4>::Constant( 4, 4, val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Row値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setRowValues( const Vec4T<T>& row0, const Vec4T<T>& row1, const Vec4T<T>& row2, const Vec4T<T>& row3 ){
	this->row( 0 ) = row0;
	this->row( 1 ) = row1;
	this->row( 2 ) = row2;
	this->row( 3 ) = row3;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Col値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setColValues( const Vec4T<T>& col0, const Vec4T<T>& col1, const Vec4T<T>& col2, const Vec4T<T>& col3 ){
	this->col( 0 ) = col0;
	this->col( 1 ) = col1;
	this->col( 2 ) = col2;
	this->col( 3 ) = col3;
}


//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分を全て同じ値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setDiagonal( T val ){
	*this = Eigen::Matrix<T, 4, 4>::Zero( 4, 4 );
	this->operator()( 0, 0 ) = this->operator()( 1, 1 ) = this->operator()( 2, 2 ) = this->operator()( 3, 3 ) = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分をVec4の値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setDiagonal( const Vec4T<T>& val ){
	*this = Eigen::Matrix<T, 4, 4>::Zero( 4, 4 );
	this->operator()( 0, 0 ) = val.x();
	this->operator()( 1, 1 ) = val.y();
	this->operator()( 2, 2 ) = val.z();
	this->operator()( 3, 3 ) = val.t();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setUpperLeft( const Mat3T<T>& mat3 ){
	this->setValue(0, 0, mat3(0,0));		this->setValue(0, 1, mat3(0,1));		this->setValue(0, 2, mat3(0,2));
	this->setValue(1, 0, mat3(1,0));		this->setValue(1, 1, mat3(1,1));		this->setValue(1, 2, mat3(1,2));
	this->setValue(2, 0, mat3(2,0));		this->setValue(2, 1, mat3(2,1));		this->setValue(2, 2, mat3(2,2));
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     方向とアップベクトルから回転（+スケール値＝1.0）を設定する (axis=0の場合は direction=Z, upV=Y)
//!		axis: 0=ZY, 1=ZX, 2=XY, 3=XZ, 4=YX, 5=YZ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setRotationFromDirectionAndUpvector( const Vec3T<T>& direction, const Vec3T<T>& upvector, u8 axis ){
	Mat3T<T> mat3;
	mat3.setFromDirectionAndUpvector( direction, upvector, axis );
	this->setUpperLeft( mat3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ポジション値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setTranslation( const Vec3T<T>& val ){
	this->operator()( 0, 3 ) = val.x();
	this->operator()( 1, 3 ) = val.y();
	this->operator()( 2, 3 ) = val.z();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     スケール値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setScaling( const Vec3T<T>& val ){
	Vec3T<T> col0( this->get(0,0), this->get(1,0), this->get(2,0) );
	Vec3T<T> col1( this->get(0,1), this->get(1,1), this->get(2,1) );
	Vec3T<T> col2( this->get(0,2), this->get(1,2), this->get(2,2) );

	col0 *= ( val.x() / col0.length() );
	col1 *= ( val.y() / col1.length() );
	col2 *= ( val.z() / col2.length() );

	this->setValue(0, 0, col0[0]);	this->setValue(0, 1, col1[0]);	this->setValue(0, 2, col2[0]);
	this->setValue(1, 0, col0[1]);	this->setValue(1, 1, col1[1]);	this->setValue(1, 2, col2[1]);
	this->setValue(2, 0, col0[2]);	this->setValue(2, 1, col1[2]);	this->setValue(2, 2, col2[2]);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Mat4T<T>::get( u8 row, u8 col ) const{
	return this->Eigen::Matrix<T, 4, 4>::coeff( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::getRowValue( u8 rowIndex ) const{
	return Vec4T<T>(this->Eigen::Matrix<T, 4, 4>::row( rowIndex ));
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     colを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::getColValue( u8 colIndex ) const{
	return Vec4T<T>( this->Eigen::Matrix<T, 4, 4>::col( colIndex ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getUpperLeft() const{
	return Mat3T<T>{this->Eigen::Matrix<T, 4, 4>::block(0, 0, 3, 3)};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getMat3() const{
	return this->getUpperLeft();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    回転値のみ（スケール値を省いた）のMat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getRotationMat3() const{
	///  Matrix44GetInverseScale_C
	Vec3T<T> scalVec3 = this->getScaling();
	if(Burgess2MathFn::IsZero( scalVec3.x() ) || Burgess2MathFn::IsZero( scalVec3.y() ) || Burgess2MathFn::IsZero( scalVec3.z() )){
		return Mat3T<T>::Zero(3,3);
	}
	Vec3T<T> invScale = scalVec3.inverse();

	Vec3T<T> row0{ this->get(0,0) * invScale.x(), this->get(0,1) * invScale.y(), this->get(0,2) * invScale.z() };
	Vec3T<T> row1{ this->get(1,0) * invScale.x(), this->get(1,1) * invScale.y(), this->get(1,2) * invScale.z() };
	Vec3T<T> row2{ this->get(2,0) * invScale.x(), this->get(2,1) * invScale.y(), this->get(2,2) * invScale.z() };
	return Mat3T<T> { row0, row1, row2 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ポジション値を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::getTranslation() const{
	return Vec3T<T> { this->get( 0, 3 ), this->get( 1, 3 ), this->get( 2, 3 )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値(Quat)を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> Mat4T<T>::getRotation() const{
	return QuatT<T> { this->getRotationMat3() };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     スケール値を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::getScaling() const{
	return this->getUpperLeft().getScaling();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    回転方向を変更する 
//!		@param[in] type ZとY方向をどの方向へ変更するか　0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ（0の場合は変更なし、3の場合はZ→X,Y→Xへ変更）
//!		@param[in] ZNeg 変更後にZの方向を反転する
//!		@param[in] YNeg 変更後にYの方向軸を反転する
//!		@param[in] keepScaleAxis スケール値を保持する場合はtrue (全軸同じスケール値であればfalseにすることで処理が高速化される)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::axisChange( u8 type, Bool ZNeg, Bool YNeg, Bool keepScaleAxis ){
	Vec3T<T> origSc = keepScaleAxis == true ? this->getScaling() : Vec3T<T>( T( 1.0 ) );
	Mat3T<T> mat3 = this->getUpperLeft();
	mat3.axisChange( type, ZNeg, YNeg );

	if(keepScaleAxis) {
		if(Burgess2MathFn::AlmostEqual( origSc[0], origSc[1] ) == false || Burgess2MathFn::AlmostEqual( origSc[0], origSc[2] ) == false || Burgess2MathFn::AlmostEqual( origSc[1], origSc[2] ) == false) {
			mat3.setScaling( origSc );
		}
	}
	this->setUpperLeft( mat3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    プラチナスタイルのリグ用：回転方向を変更する 
//!		@param[in] type XとZ方向をどの方向へ変更するか　0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ（2の場合は変更なし、0の場合はX→Z,Z→Yへ変更）
//!		@param[in] XNeg 変更後にXの方向を反転する
//!		@param[in] ZNeg 変更後にZの方向軸を反転する
//!		@param[in] keepScaleAxis スケール値を保持する場合はtrue (全軸同じスケール値であればfalseにすることで処理が高速化される)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::axisChangeXZ( u8 type, Bool XNeg, Bool ZNeg, Bool keepScaleAxis ){
	Vec3T<T> origTr = this->getTranslation();
	Vec3T<T> origSc = keepScaleAxis == true ? this->getScaling() : Vec3T<T>( T( 1.0 ) );
	Mat3T<T> mat3 = this->getUpperLeft();
	Vec3T<T> xA = mat3.getXaxis();
	Vec3T<T> yA = mat3.getYaxis();
	Vec3T<T> zA = mat3.getZaxis();
	Vec3T<T> tr = origTr;
	if(XNeg == true && ZNeg == false) {
		yA.setNegate();
		xA.setNegate();
		origTr *= Vec3T<T>( T( -1.0 ), T( -1.0 ), T( 1.0 ) );
	} else if(XNeg == false && ZNeg == true) {
		zA.setNegate();
		yA.setNegate();
		origTr *= Vec3T<T>( T( 1.0 ), T( -1.0 ), T( -1.0 ) );
	} else if(XNeg == true && ZNeg == true) {
		xA.setNegate();
		zA.setNegate();
		origTr *= Vec3T<T>( T( -1.0 ), T( 1.0 ), T( -1.0 ) );
	}
	switch(type) {
		case 0:
			mat3.setAxis( zA, xA, yA );
			tr = Vec3T<T>{ origTr.z(), origTr.x(), origTr.y() };
			break;
		case 1:
			mat3.setAxis( zA, yA.negate(), xA );
			tr = Vec3T<T>{ origTr.z(), -origTr.y(), origTr.x() };
			break;
		case 2:
			mat3.setAxis( xA, yA, zA );
			tr = Vec3T<T>{ origTr.x(), origTr.y(), origTr.z() };
			break;
		case 3:
			mat3.setAxis( xA, zA.negate(), yA );
			tr = Vec3T<T>{ origTr.x(), -origTr.z(), origTr.y() };
			break;
		case 4:
			mat3.setAxis( yA, zA, xA );
			tr = Vec3T<T>{ origTr.y(), origTr.z(), origTr.x() };
			break;
		case 5:
			mat3.setAxis( yA, xA.negate(), zA );
			tr = Vec3T<T>{ origTr.y(), -origTr.x(), origTr.y() };
			break;
	}

	if(keepScaleAxis) {
		if(Burgess2MathFn::AlmostEqual( origSc[0], origSc[1] ) == false || Burgess2MathFn::AlmostEqual( origSc[0], origSc[2] ) == false || Burgess2MathFn::AlmostEqual( origSc[1], origSc[2] ) == false) {
			mat3.setScaling( origSc );
		}
	}
	this->setUpperLeft( mat3 );
	this->setTranslation( tr );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::transpose() const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::transpose()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setTranspose(){
	*this = this->Eigen::Matrix<T, 4, 4>::transpose();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::inverse() const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::inverse()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setInverse(){
	*this = this->Eigen::Matrix<T, 4, 4>::inverse();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     共役マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::conjugate() const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::conjugate()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     共役マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setConjugate(){
	*this = this->Eigen::Matrix<T, 4, 4>::conjugate();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::swapRows( u8 row1, u8 row2 ){
	this->Eigen::Matrix<T, 4, 4>::row( row1 ).swap( this->Eigen::Matrix<T, 4, 4>::row( row2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     col値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::swapCols( u8 col1, u8 col2 ){
	this->Eigen::Matrix<T, 4, 4>::col( col1 ).swap( this->Eigen::Matrix<T, 4, 4>::col( col2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     行列式を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T Mat4T<T>::determinant() const{
	return T( this->Eigen::Matrix<T, 4, 4>::determinant() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>& Mat4T<T>::operator = ( const Eigen::Matrix<T, 4, 4>& other ){
	this->Eigen::Matrix<T, 4, 4>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Mat4T<T>::operator()( u8 row, u8 col ){
	return this->Eigen::Matrix<T, 4, 4>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Mat4T<T>::operator()( u8 row, u8 col ) const{
	return this->Eigen::Matrix<T, 4, 4>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::operator == ( const Mat4T& other ) const{
	return this->Eigen::Matrix<T, 4, 4>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::operator != ( const Mat4T& other ) const{
	return this->Eigen::Matrix<T, 4, 4>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator + ( const Mat4T& other ) const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::operator+( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator += ( const Mat4T& other ){
	this->Eigen::Matrix<T, 4, 4>::operator+=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator - ( const Mat4T& other ) const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::operator-( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator -= ( const Mat4T& other ){
	this->Eigen::Matrix<T, 4, 4>::operator-=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator * ( const Mat4T& other ) const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::operator*( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::operator * ( const Vec4T<T>& vec4 ) const{
	return Vec4T<T>{this->Eigen::Matrix<T, 4, 4>::operator*( vec4 )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::operator * ( const Vec3T<T>& vec3 ) const{
	Vec4T<T> v4{ vec3[0], vec3[1], vec3[2], T( 1.0 ) };
	return Vec3T<T>{this->Eigen::Matrix<T, 4, 4>::operator*( v4 )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator * ( T val ) const{
	return Mat4T<T>{this->Eigen::Matrix<T, 4, 4>::operator*( val )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator *= ( const Mat4T& other ){
	this->Eigen::Matrix<T, 4, 4>::operator*=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator *= ( T val ){
	this->Eigen::Matrix<T, 4, 4>::operator*=( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator / ( T val ) const{
	return this->Eigen::Matrix<T, 4, 4>::operator/( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator /= ( T val ){
	this->Eigen::Matrix<T, 4, 4>::operator/=( val );
}
