//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT() : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>{ Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 ) }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( s32 n ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>( Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( n,n ) )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( s32 rowSize, s32 colSize ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>( Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( rowSize, colSize ) )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row size = std::vector<T>::size() / col size = VecT<T>::size()
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( const std::vector<VecT<T>>& vecArray ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(){
	s32 rowSize = s32( vecArray.size() );
	if ( rowSize == 0 ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 );
		return;
	}

	s32 colSize = vecArray[0].size();
	if ( colSize == 0 ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 );
		return;
	}

	this->reset( rowSize, colSize );
	for ( s32 i = 0; i < rowSize; ++i ){
		for ( s32 j = 0; j < colSize; ++j ){
			this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, j ) = vecArray[i][j];
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row size = std::vector<T>::size() / col size = 3
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( const std::vector<Vec3T<T>>& vecArray ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(){
	if ( vecArray.size() == 0 ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 );
		return;
	}

	this->reset( vecArray.size(), 3 );
	for ( s32 i = 0; i < vecArray.size(); ++i ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 0 )  = vecArray[i][0];
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 1 )  = vecArray[i][1];
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 2 )  = vecArray[i][2];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row size = std::vector<T>::size() / col size = 4
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( const std::vector<Vec4T<T>>& vecArray ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(){
	if ( vecArray.size() == 0 ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 );
		return;
	}

	this->reset( vecArray.size(), 4 );
	for ( s32 i = 0; i < vecArray.size(); ++i ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 0 ) = vecArray[i][0];
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 1 ) = vecArray[i][1];
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 2 ) = vecArray[i][2];
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( i, 3 ) = vecArray[i][3];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( const VecT<T>& data, const s32 rowSize, const s32 colSize, Bool argDataIsColumnMajor ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(){
	*this = MatT<T>{ data.toTypeArray(), rowSize, colSize, argDataIsColumnMajor };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( std::vector<T>& data, const s32 rowSize, const s32 colSize, Bool argDataIsColumnMajor ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(){
	if ( data.size() != rowSize * colSize ){
		this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( 1, 1 );
		return;
	}

	if ( argDataIsColumnMajor ){
		*this = MatT<T>{ Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>( data.data(), rowSize, colSize ) };
	}else{
		*this = MatT<T>{ Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>( data.data(), colSize, rowSize ) };
		this->setTranspose();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>::MatT( const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& other ) : Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>( other )
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     サイズを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
s32 MatT<T>::size() const{
	return this->rowSize() * this->colSize();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::toVec( Bool toColumnMajorVal ) const{
	return VecT<T>( this->toTypeArray( toColumnMajorVal ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列に変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> MatT<T>::toTypeArray( Bool toColumnMajorVal )const{
	std::vector<T> stdVec( this->size() );
	if( toColumnMajorVal ){
		Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>( stdVec.data(), this->rowSize(), this->colSize() ) = *this;
	} else{
		s32 c = 0;
		for(s32 i = 0; i < this->rowSize(); ++i){
			for(s32 j = 0; j < this->colSize(); ++j){
				stdVec[c] = this->get( i, j );
				++c;
			}
		}
	}
	return stdVec;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String MatT<T>::toString( const String title ) const{
	String t = title;
	if ( title.length() != 0 ){ t += " : "; }
	String s = "values[";
	std::vector<T> v = this->toTypeArray();
	for ( u32 i = 0; i < v.size() - 1; i++ ){
		s += GetFloorString( v[i] ) + ", ";
	}
	s += GetFloorString( v[v.size() - 1] ) + "]";
	return t + "Mat:[rowSize=" + std::to_string( this->rowSize() ) + " / colSize=" + std::to_string( this->colSize() ) + " / " + s + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowのサイズを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
s32 MatT<T>::rowSize() const{
	return s32(this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::rows());
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowのサイズを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
s32 MatT<T>::colSize() const{
	return s32(this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::cols());
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が完全に同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::equal( const MatT& other ) const{
	return this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が許容範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::almostEqual( const MatT& other, T tolerance ) const{
	for ( s32 i = 0; i < this->size(); ++i ){
		assert( std::isnan( this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator[]( i ) ) == false &&
				std::isnan( other.Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator[]( i ) ) == false );

		Bool ae = Burgess2MathFn::AlmostEqual( this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator[]( i ),
									 other.Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator[]( i ),
									 tolerance );
		if ( ae == false ){ return false; }
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     正方形マトリックスの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::isSquare() const{
	return this->rowSize() == this->colSize();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     リサイズ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::resize( s32 rowSize, s32 colSize ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::resize( Burgess2MathFn::Max(1,rowSize), Burgess2MathFn::Max(1,colSize) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     リセット
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::reset( s32 rowSize, s32 colSize ){
	*this = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( Burgess2MathFn::Max( 1, rowSize ), Burgess2MathFn::Max( 1, colSize ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ゼロマトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setZero( ){
	*this = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero( this->rowSize(), this->colSize() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値をセットする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setValue( s32 index, T val ){
	assert( index < this->size() );
	this->operator[](index) = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値をセットする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setValue( s32 _row, s32 _col, T val ){
	assert( _row < this->rowSize() && _col < this->colSize() );
	this->operator()(_row, _col) = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全ての要素を同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setAllValue( T val ){
	*this = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Constant( this->rowSize(), this->colSize(), val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowを同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setRowAllValues( s32 rowIndex, T val ){
	for ( s32 i = 0; i < this->colSize(); ++i ){
		this->operator()( rowIndex, i ) = val;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowを設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setRowValues( s32 rowIndex, const VecT<T>& vec ){
	std::vector<T> v = vec.toTypeArray();
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::row( rowIndex ) = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &v[0], v.size() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     colを同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setColAllValues( s32 colIndex, T val ){
	for ( s32 i = 0; i < this->rowSize(); ++i ){
		this->operator()( i, colIndex ) = val;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     colを設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setColValues( s32 colIndex, const VecT<T>& vec ){
	std::vector<T> v = vec.toTypeArray();
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::col( colIndex ) = Eigen::Map<Eigen::Vector<T, Eigen::Dynamic>>( &v[0], v.size() );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T MatT<T>::get( s32 row, s32 col )const{
	return this->operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     rowを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getRowValue( s32 rowIndex )const{
	std::vector<T> r( this->colSize() );
	for ( s32 i = 0; i < this->colSize(); ++i ){
		r[i] = this->operator()( rowIndex, i );
	}

	return VecT<T>{r};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     colを取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::getColValue( s32 colIndex )const{
	std::vector<T> c( this->rowSize() );
	for ( s32 i = 0; i < this->rowSize(); ++i ){
		c[i] = this->operator()( i, colIndex );
	}

	return VecT<T>{c};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックス内の最小値のIndex(row,col)を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec2u MatT<T>::getMinIndex()const{
	Eigen::Index r, c;
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::minCoeff( &r, &c );
	return Vec2u{ u32(r), u32(c) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックス内の最大値のIndex(row,col)を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec2u MatT<T>::getMaxIndex()const{
	Eigen::Index r, c;
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::maxCoeff( &r, &c );
	return Vec2u{ u32( r ), u32( c ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::transpose() const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::transpose()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setTranspose(){
	*this = this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::transpose();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::inverse() const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::inverse()};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::setInverse(){
	*this = this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::inverse();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::swapRows( s32 row1, s32 row2 ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::row( row1 ).swap( this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::row( row2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     col値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::swapCols( s32 col1, s32 col2 ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::col( col1 ).swap( this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::col( col2 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T>& MatT<T>::operator = ( const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& other ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator=( other );
	return *this;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& MatT<T>::operator()( s32 row, s32 col ){
	return this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     要素へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& MatT<T>::operator()( s32 row, s32 col ) const{
	return this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator()( row, col );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::operator == ( const MatT<T>& other ) const{
	return this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator==( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool MatT<T>::operator != ( const MatT<T>& other ) const{
	return this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator!=( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::operator + ( const MatT<T>& other ) const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator + ( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator += ( const MatT<T>& other ) {
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator += ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::operator - ( const MatT<T>& other ) const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator - ( other )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator -= ( const MatT<T>& other ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator -= ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> MatT<T>::operator * ( const VecT<T>& other ) const{
	Eigen::Matrix<T, Eigen::Dynamic, 1> val = this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator * ( other );
	return VecT<T> {val};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::operator * ( T val ) const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator * ( val )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator *= ( T val ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator *= ( val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
MatT<T> MatT<T>::operator / ( T val ) const{
	return MatT<T>{this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator / ( val )};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void MatT<T>::operator /= ( T val ){
	this->Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::operator /= ( val );
}