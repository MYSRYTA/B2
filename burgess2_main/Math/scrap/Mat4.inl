
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T () {
	this->setIdentity ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( T _00, T _01, T _02, T _03, T _10, T _11, T _12, T _13, T _20, T _21, T _22, T _23, T _30, T _31, T _32, T _33 )
	: row { 
		Vec4T<T> { _00, _01, _02, _03 } ,
		Vec4T<T> { _10, _11, _12, _13 } ,
		Vec4T<T> { _20, _21, _22, _23 } ,
		Vec4T<T> { _30, _31, _32, _33 } 
	}
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const Mat3T<T> &m ) {
	this->setIdentity ();
	this->setUpperLeft ( m );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const Mat4T<T> &m ) {
	for ( u8 i = 0; i<4; i++ ) {
		( *this ) [i] = m [i];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const Vec4T<T> &_row0, const Vec4T<T> &_row1, const Vec4T<T> &_row2, const Vec4T<T> &_row3 )
	: row { _row0 , _row1, _row2, _row3 }{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const VecT<T> &vec ) {
	assert ( 16 <= vec.size () );
	Vec4T<T> row0 { vec [0], vec [1], vec [2], vec [3] };
	Vec4T<T> row1 { vec [4], vec [5], vec [6], vec [7] };
	Vec4T<T> row2 { vec [8], vec [9], vec [10], vec [11] };
	Vec4T<T> row3 { vec [12], vec [13], vec [14], vec [15] };
	*this = Mat4T<T> { row0, row1, row2, row3 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const std::vector<T> &typeArray ) {
	assert ( 16 <= typeArray.size () );
	Vec4T<T> row0 { typeArray [0], typeArray [1], typeArray [2], typeArray [3] };
	Vec4T<T> row1 { typeArray [4], typeArray [5], typeArray [6], typeArray [7] };
	Vec4T<T> row2 { typeArray [8], typeArray [9], typeArray [10], typeArray [11] };
	Vec4T<T> row3 { typeArray [12], typeArray [13], typeArray [14], typeArray [15] };
	*this = Mat4T<T> { row0, row1, row2, row3 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const XfoT<T> &xfo ) {
	*this = xfo.toMat4 ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T>::Mat4T ( const SRTT<T> &srt ){
	*this = srt.toMat4 ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位マトリックス（対角線座標の値＝１、その他＝０）にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setIdentity () {
	this->setAllVal ( T(0.0) );
	this->setDiagonal ( T ( 1.0 ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     指定した座標の値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setValue ( u8 row, u8 col, T value ) {
	assert ( row < 4 && col < 4 );
	( *this ) [row] [col] = value;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     全ての要素を同じ値にする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setAllVal ( T val ) {
	Vec4T<T> v4 { val };
	for ( u8 i = 0; i<4; i++ ) {
		( *this ) [i] = v4;;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Row値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setRowValues ( const Vec4T<T> &row0, const Vec4T<T> &row1, const Vec4T<T> &row2, const Vec4T<T> &row3 ) {
	( *this ) [0] = row0;
	( *this ) [1] = row1;
	( *this ) [2] = row2;
	( *this ) [3] = row3;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Col値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setColValues ( const Vec4T<T> &col0, const Vec4T<T> &col1, const Vec4T<T> &col2, const Vec4T<T> &col3 ) {
	( *this ) [0][0] = col0[0]; ( *this ) [0][1] = col1[0]; ( *this ) [0][2] = col2[0]; ( *this ) [0][3] = col3[0];
	( *this ) [1][0] = col0[1]; ( *this ) [1][1] = col1[1]; ( *this ) [1][2] = col2[1]; ( *this ) [1][3] = col3[1];
	( *this ) [2][0] = col0[2]; ( *this ) [2][1] = col1[2]; ( *this ) [2][2] = col2[2]; ( *this ) [2][3] = col3[2];
	( *this ) [3][0] = col0[3]; ( *this ) [3][1] = col1[3]; ( *this ) [3][2] = col2[3]; ( *this ) [3][3] = col3[3];
}


//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分を全て同じ値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setDiagonal ( T val ) {
	this->setAllVal ( T(0.0) );
	( *this )[0][0] = ( *this )[1][1] = ( *this )[2][2] = ( *this )[3][3] = val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     マトリックスの対角成分をVec4の値、その他を０に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setDiagonal ( const Vec4T<T> &val ) {
	this->setAllVal ( T(0.0) );
	( *this ) [0].x = val.x;
	( *this ) [1].y = val.y;
	( *this ) [2].z = val.z;
	( *this ) [3].t = val.t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setUpperLeft ( const Mat3T<T> &mat3 ) {
	( *this )[0][0] = mat3[0][0];		( *this )[0][1] = mat3[0][1];		( *this )[0][2] = mat3[0][2];
	( *this )[1][0] = mat3[1][0];		( *this )[1][1] = mat3[1][1];		( *this )[1][2] = mat3[1][2];
	( *this )[2][0] = mat3[2][0];		( *this )[2][1] = mat3[2][1];		( *this )[2][2] = mat3[2][2];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     方向とアップベクトルから回転（+スケール値＝1.0）を設定する (axis=0の場合は direction=Z, upV=Y)
//!		axis: 0=ZY, 1=ZX, 2=XY, 3=XZ, 4=YX, 5=YZ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setRotationFromDirectionAndUpvector ( const Vec3T<T> &direction, const Vec3T<T> &upvector, u8 axis ) {
	Mat3T<T> mat3;
	mat3.setFromDirectionAndUpvector ( direction, upvector, axis );
	(*this)[0][0] = mat3[0][0];		(*this)[0][1] = mat3[0][1];		(*this)[0][2] = mat3[0][2];
	(*this)[1][0] = mat3[1][0];		(*this)[1][1] = mat3[1][1];		(*this)[1][2] = mat3[1][2];
	(*this)[2][0] = mat3[2][0];		(*this)[2][1] = mat3[2][1];		(*this)[2][2] = mat3[2][2];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ポジション値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setTranslation ( const Vec3T<T> &val) {
	this->row [0].t = val.x;
	this->row [1].t = val.y;
	this->row [2].t = val.z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     スケール値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setScaling ( const Vec3T<T> &val ) {
	T len;

	Vec3 col0 ( this->row[0].x, this->row[1].x, this->row[2].x );
	Vec3 col1 ( this->row[0].y, this->row[1].y, this->row[2].y );
	Vec3 col2 ( this->row[0].z, this->row[1].z, this->row[2].z );

	len = col0.length ();
	col0 *= (val.x / len);

	len = col1.length ();
	col1 *= (val.y / len);

	len = col2.length ();
	col2 *= (val.z / len);

	this->row[0].x = col0.x;
	this->row[1].x = col0.y;
	this->row[2].x = col0.z;
	this->row[0].y = col1.x;
	this->row[1].y = col1.y;
	this->row[2].y = col1.z;
	this->row[0].z = col2.x;
	this->row[1].z = col2.y;
	this->row[2].z = col2.z;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    回転方向を変更する 
//!		@param[in] type ZとY方向をどの方向へ変更するか　0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ（0の場合は変更なし、3の場合はZ→X,Y→Xへ変更）
//!		@param[in] ZNeg 変更後にZの方向を反転する
//!		@param[in] YNeg 変更後にYの方向軸を反転する
//!		@param[in] keepScaleAxis スケール値を保持する場合はtrue (全軸同じスケール値であればfalseにすることで処理が高速化される)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::axisChangeZY(u8 type, Bool ZNeg, Bool YNeg, Bool keepScaleAxis) {
	if (6 <= type) { return; }

	Vec3T<T> origSc = keepScaleAxis == true ? this->getScaling() : Vec3T<T>(T(1.0));
	Mat3T<T> mat3 = this->getUpperLeft();
	mat3.axisChange ( type, ZNeg, YNeg );
	
	if (keepScaleAxis) {
		if ( Math::AlmostEqual ( origSc.x, origSc.y ) == false || Math::AlmostEqual ( origSc.x, origSc.z ) == false || Math::AlmostEqual ( origSc.y, origSc.z ) == false ) {
			mat3.setScaling ( origSc );
		}
	}
	this->setUpperLeft(mat3);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    回転方向を変更する 
//!		@param[in] type XとZ方向をどの方向へ変更するか　0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ（2の場合は変更なし、0の場合はX→Z,Z→Yへ変更）
//!		@param[in] XNeg 変更後にXの方向を反転する
//!		@param[in] ZNeg 変更後にZの方向軸を反転する
//!		@param[in] keepScaleAxis スケール値を保持する場合はtrue (全軸同じスケール値であればfalseにすることで処理が高速化される)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::axisChangeXZ(u8 type, Bool XNeg, Bool ZNeg, Bool keepScaleAxis) {
	if (6 <= type) { return; }

	Vec3T<T> origTr = this->getTranslation();
	Vec3T<T> origSc = keepScaleAxis == true ? this->getScaling() : Vec3T<T>(T(1.0));
	Mat3T<T> mat3 = this->getUpperLeft();
	Vec3T<T> xA = mat3.getXaxis();
	Vec3T<T> yA = mat3.getYaxis();
	Vec3T<T> zA = mat3.getZaxis();
	Vec3T<T> tr = origTr;
	if (XNeg == true && ZNeg == false) {
		yA.setNegate();
		xA.setNegate();
		origTr *= Vec3T<T>(T(-1.0), T(-1.0), T(1.0));
	}
	else if (XNeg == false && ZNeg == true) {
		zA.setNegate();
		yA.setNegate();
		origTr *= Vec3T<T>(T(1.0), T(-1.0), T(-1.0));
	}
	else if (XNeg == true && ZNeg == true) {
		xA.setNegate();
		zA.setNegate();
		origTr *= Vec3T<T>(T(-1.0), T(1.0), T(-1.0));
	}
	switch (type) {
	case 0:
		mat3.setXaxis(zA);
		mat3.setYaxis(xA);
		mat3.setZaxis(yA);
		tr.x = origTr.z;
		tr.y = origTr.x;
		tr.z = origTr.y;
		break;
	case 1:
		mat3.setXaxis(zA);
		mat3.setYaxis(yA.negate());
		mat3.setZaxis(xA);
		tr.x = origTr.z;
		tr.y = origTr.y * T(-1.0);
		tr.z = origTr.x;
		break;
	case 2:
		mat3.setXaxis(xA);
		mat3.setYaxis(yA);
		mat3.setZaxis(zA);
		tr.x = origTr.x;
		tr.y = origTr.y;
		tr.z = origTr.z;
		break;
	case 3:
		mat3.setXaxis(xA);
		mat3.setYaxis(zA.negate());
		mat3.setZaxis(yA);
		tr.x = origTr.x;
		tr.y = origTr.z * T(-1.0);
		tr.z = origTr.y;
		break;
	case 4:
		mat3.setXaxis(yA);
		mat3.setYaxis(zA);
		mat3.setZaxis(xA);
		tr.x = origTr.y;
		tr.y = origTr.z;
		tr.z = origTr.x;
		break;
	case 5:
		mat3.setXaxis(yA);
		mat3.setYaxis(xA.negate());
		mat3.setZaxis(zA);
		tr.x = origTr.y;
		tr.y = origTr.x * T(-1.0);
		tr.z = origTr.y;
		break;
	}

	if (keepScaleAxis) {
		mat3.setScaling(origSc);
	}
	this->setUpperLeft(mat3);
	this->setTranslation(tr);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      座標の値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
inline T Mat4T<T>::get ( u8 row, u8 col ) const {
	assert ( row < 4 && col < 4 );
	return ( *this ) [row] [col];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      row値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::getRowValues ( u8 rowIndex ) const {
	assert ( rowIndex < 4 );
	return this->row [rowIndex];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      col値を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::getColValues ( u8 colIndex ) const {
	assert ( colIndex < 4 );
	return Vec4T<T> { this->row[0] [colIndex], this->row [1] [colIndex], this->row [2] [colIndex], this->row [3] [colIndex]};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ポジション値を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::getTranslation () const {
	return Vec3T<T> { this->row [0].t, this->row [1].t, this->row [2].t};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値(Quat)を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> Mat4T<T>::getRotation () const {
	Mat3T<T> m3 = this->getRotationMat3 ();
	return QuatT<T> { m3 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     スケール値を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::getScaling () const {
	Mat3T<T> m3 = this->getUpperLeft();
	return m3.getScaling();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getUpperLeft () const {
	Mat3T<T> result;
	result [0][0] = ( *this )[0][0];	result [0][1] = ( *this )[0][1];	result [0][2] = ( *this )[0][2];
	result [1][0] = ( *this )[1][0];	result [1][1] = ( *this )[1][1];	result [1][2] = ( *this )[1][2];
	result [2][0] = ( *this )[2][0];	result [2][1] = ( *this )[2][1];	result [2][2] = ( *this )[2][2];
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getMat3 () const {
	return this->getUpperLeft ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    回転値のみ（スケール値を省いた）のMat3を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Mat4T<T>::getRotationMat3 () const {
	///  Matrix44GetInverseScale_C
	Vec3T<T> scalVec3 = this->getScaling ();
	assert ( Math::IsZero ( scalVec3.x ) == Math::IsZero ( scalVec3.y ) == Math::IsZero ( scalVec3.z ) == false );
	Vec3T<T> invScale = scalVec3.inverse ();

	/// Matrix44GetRotationMatrix_C
	Vec3T<T> row0 { ( *this )[0][0] *invScale.x, ( *this )[0][1]*invScale.y, ( *this )[0][2]*invScale.z };
	Vec3T<T> row1 { ( *this )[1][0] *invScale.x, ( *this )[1][1]*invScale.y, ( *this )[1][2]*invScale.z };
	Vec3T<T> row2 { ( *this )[2][0] *invScale.x, ( *this )[2][1]*invScale.y, ( *this )[2][2]*invScale.z };
	return Mat3T<T> { row0, row1, row2 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Mat4T<T>::toVec () const {
	VecT<T> vec ( 16 );
	for ( u8 i = 0; i<4; i++ ) {
		for ( u8 j = 0; j<4; j++ ) {
			vec [4 * i + j] = ( *this ) [i] [j];
		}
	}
	return vec;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列に変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Mat4T<T>::toTypeArray ()const {
	std::vector<T> result { 16 };
	for ( u8 i = 0; i<4; i++ ) {
		for ( u8 j = 0; j<4; j++ ) {
			result [4 * i + j] = ( *this ) [i] [j];
		}
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Xfoに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
XfoT<T> Mat4T<T>::toXfo()const{
	Vec3T<T> translation = this->getTranslation ();
	Vec3T<T> scaling = this->getScaling ();
	QuatT<T> ori = this->getRotation ();
	return XfoT<T> { scaling, ori, translation };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     SRTに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> Mat4T<T>::toSRT ( u8 order )const{
	Vec3T<T> translation = this->getTranslation ();
	Vec3T<T> scaling = this->getScaling ();
	Deg3T<T> ori = Deg3T<T>{ this->getRotation (), order };
	return SRTT<T> { scaling, ori, translation };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Mat4T<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	String row0 = "row0 [" + GetFloorString ( this->row[0].x ) + ", " + GetFloorString ( this->row[0].y ) + ", " + GetFloorString ( this->row[0].z ) + ", " + GetFloorString ( this->row[0].t ) + "] / ";
	String row1 = "row1 [" + GetFloorString ( this->row[1].x ) + ", " + GetFloorString ( this->row[1].y ) + ", " + GetFloorString ( this->row[1].z ) + ", " + GetFloorString ( this->row[1].t ) + "] / ";
	String row2 = "row2 [" + GetFloorString ( this->row[2].x ) + ", " + GetFloorString ( this->row[2].y ) + ", " + GetFloorString ( this->row[2].z ) + ", " + GetFloorString ( this->row[2].t ) + "] / ";
	String row3 = "row3 [" + GetFloorString ( this->row[3].x ) + ", " + GetFloorString ( this->row[3].y ) + ", " + GetFloorString ( this->row[3].z ) + ", " + GetFloorString ( this->row[3].t ) + "]";
	return t + "Mat4:[" + row0 + row1 + row2 + row3 + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が完全に同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::equal ( const Mat4T &other ) const {
	return 
		this->row[0].equal ( other.row[0] ) && 
		this->row[1].equal ( other.row[1] ) && 
		this->row[2].equal ( other.row[2] ) && 
		this->row[3].equal ( other.row[3] );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのマトリックスの値が許容範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::almostEqual ( const Mat4T &other, T tolerance ) const {
	return
		this->row[0].almostEqual ( other.row[0], tolerance ) &&
		this->row[1].almostEqual ( other.row[1], tolerance ) &&
		this->row[2].almostEqual ( other.row[2], tolerance ) &&
		this->row[3].almostEqual ( other.row[3], tolerance );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     zero matrixの場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::isZero ( ) const {
	for ( u32 i = 0; i < 4; i++ ) {
		for ( u32 j = 0; j < 4; j++ ) {
			if ( Math::AlmostEqual ( (*this)[i][j], T ( 0.0 ), T ( 0.001 ) ) == false ) {
				return false;
			}
		}
	}
	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::transpose () const {
	Mat4T<T> result;
	result.setColValues ( this->row[0], this->row[1], this->row[2], this->row[3] );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     転置（対角線で成分を折り返した）マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setTranspose () {
	*this = this->transpose ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::inverse () const {
	/// Matrix44AffineInverse_C
	T det =
			( *this )[0][0] * ( *this )[1][1] * ( *this )[2][2]
		+ ( *this )[1][0] * ( *this )[2][1] * ( *this )[0][2]
		+ ( *this )[2][0] * ( *this )[0][1] * ( *this )[1][2]
		- ( *this )[0][0] * ( *this )[2][1] * ( *this )[1][2]
		- ( *this )[1][0] * ( *this )[0][1] * ( *this )[2][2]
		- ( *this )[2][0] * ( *this )[1][1] * ( *this )[0][2];
	assert ( Math::IsZero ( det ) == false );

	Mat4T<T> result;
	Vec4T<T> col0 { 0.0 };
	col0.x = ( *this )[1][1] * ( *this )[2][2] - ( *this )[2][1] * ( *this )[1][2];
	col0.y = ( *this )[2][0] * ( *this )[1][2] - ( *this )[1][0] * ( *this )[2][2];
	col0.z = ( *this )[1][0] * ( *this )[2][1] - ( *this )[2][0] * ( *this )[1][1];

	Vec4T<T> col1 { 0.0 };
	col1.x = ( *this )[2][1] * ( *this )[0][2] - ( *this )[0][1] * ( *this )[2][2];
	col1.y = ( *this )[0][0] * ( *this )[2][2] - ( *this )[2][0] * ( *this )[0][2];
	col1.z = ( *this )[2][0] * ( *this )[0][1] - ( *this )[0][0] * ( *this )[2][1];

	Vec4T<T> col2 { 0.0 };
	col2.x = ( *this )[0][1] * ( *this )[1][2] - ( *this )[1][1] * ( *this )[0][2];
	col2.y = ( *this )[1][0] * ( *this )[0][2] - ( *this )[0][0] * ( *this )[1][2];
	col2.z = ( *this )[0][0] * ( *this )[1][1] - ( *this )[1][0] * ( *this )[0][1];

	Vec4T<T> col3;
	col3.x = -( col0.x * ( *this )[0][3] + col1.x * ( *this )[1][3] + col2.x * ( *this )[2][3] );
	col3.y = -( col0.y * ( *this )[0][3] + col1.y * ( *this )[1][3] + col2.y * ( *this )[2][3] );
	col3.z = -( col0.z * ( *this )[0][3] + col1.z * ( *this )[1][3] + col2.z * ( *this )[2][3] );
	col3.t = det;

	result.setColValues ( col0, col1, col2, col3 );

	return result * (T(1.0) / det);

	// LAPACK
	/*integer    m = 4; // 行のサイズ
	integer    n = 4; // 列のサイズ
	integer    lda = 4; // mと同じ値
	double A[16]; // m x n の行列成分。この行列の逆行列を求める。
	A[0] = ( *this )[0][0]; A[4] = ( *this )[0][1]; A[8] = ( *this )[0][2]; A[12] = ( *this )[0][3];
	A[1] = ( *this )[1][0]; A[5] = ( *this )[1][1]; A[9] = ( *this )[1][2]; A[13] = ( *this )[1][3];
	A[2] = ( *this )[2][0]; A[6] = ( *this )[2][1]; A[10] = ( *this )[2][2]; A[14] = ( *this )[2][3];
	A[3] = ( *this )[3][0]; A[7] = ( *this )[3][1]; A[11] = ( *this )[3][2]; A[15] = ( *this )[3][3];
	integer    info; // 計算が成功すれば0を返す
	integer    ipiv[4]; // 要素数はm,nのうち小さい方とする
	integer    lwork = 4; // nと同じ値
	double work[4]; // 要素数はlworkと同じ値
	// LAPACKのdgetrfサブルーチンを呼んで、行列AをLU分解
	dgetrf_ ( &m, &n, A, &lda, ipiv, &info );
	// LU分解後の行列から逆行列を求める
	// 逆行列は元の配列Aに入る
	dgetri_ ( &n, A, &lda, ipiv, work, &lwork, &info );

	Mat4T<T> result{
		T ( A[0] ), T ( A[4] ), T ( A[8] ),  T ( A[12] ),
		T ( A[1] ), T ( A[5] ), T ( A[9] ),  T ( A[13] ),
		T ( A[2] ), T ( A[6] ), T ( A[10] ), T ( A[14] ),
		T ( A[3] ), T ( A[7] ), T ( A[11] ), T ( A[15] )
	};
	return result;*/
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数マトリックスにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::setInverse () {
	*this = this->inverse ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::swapRows ( u8 row1, u8 row2 ) {
	Vec4T<T> rest = this->getRowValues ( row1 );
	this->setRowValues ( row1, this->getRowValues ( row2 ) );
	this->setRowValues ( row2, rest );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     col値を入れ替える
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::swapCols ( u8 col1, u8 col2 ) {
	Vec4T<T> rest = this->getColValues ( col1 );
	this->setColValues ( col1, this->getColValues ( col2 ) );
	this->setColValues ( col2, rest );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     row[0~3]へのアクセス
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T>& Mat4T<T>::operator[]( u8 id ) {
	assert ( id < 4 );
	return this->row [id];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const Vec4T<T>& Mat4T<T>::operator[]( u8 id ) const {
	assert ( id < 4 );
	return this->row [id];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::operator == ( const Mat4T &other ) const {
	return this->equal ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Mat4T<T>::operator != ( const Mat4T &other ) const {
	return !this->equal ( other );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator + ( const Mat4T &other ) const {
	return Mat4T<T> {
		this->row[0] + other.row[0],
		this->row[1] + other.row[1],
		this->row[2] + other.row[2],
		this->row[3] + other.row[3] 
	};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator += ( const Mat4T &other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator - ( const Mat4T &other ) const {
	return Mat4T<T> {
		this->row [0] - other.row [0],
		this->row [1] - other.row [1],
		this->row [2] - other.row [2],
		this->row [3] - other.row [3] 
	};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator -= ( const Mat4T &other ) {
	*this = *this - other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator * ( const Mat4T &other ) const {
	Mat4T<T> result;
	result[0][0] = ( *this )[0][0] * other[0][0] + ( *this )[0][1] * other[1][0] + ( *this )[0][2] * other[2][0] + ( *this )[0][3] * other[3][0];
	result[0][1] = ( *this )[0][0] * other[0][1] + ( *this )[0][1] * other[1][1] + ( *this )[0][2] * other[2][1] + ( *this )[0][3] * other[3][1];
	result[0][2] = ( *this )[0][0] * other[0][2] + ( *this )[0][1] * other[1][2] + ( *this )[0][2] * other[2][2] + ( *this )[0][3] * other[3][2];
	result[0][3] = ( *this )[0][0] * other[0][3] + ( *this )[0][1] * other[1][3] + ( *this )[0][2] * other[2][3] + ( *this )[0][3] * other[3][3];

	result[1][0] = ( *this )[1][0] * other[0][0] + ( *this )[1][1] * other[1][0] + ( *this )[1][2] * other[2][0] + ( *this )[1][3] * other[3][0];
	result[1][1] = ( *this )[1][0] * other[0][1] + ( *this )[1][1] * other[1][1] + ( *this )[1][2] * other[2][1] + ( *this )[1][3] * other[3][1];
	result[1][2] = ( *this )[1][0] * other[0][2] + ( *this )[1][1] * other[1][2] + ( *this )[1][2] * other[2][2] + ( *this )[1][3] * other[3][2];
	result[1][3] = ( *this )[1][0] * other[0][3] + ( *this )[1][1] * other[1][3] + ( *this )[1][2] * other[2][3] + ( *this )[1][3] * other[3][3];

	result[2][0] = ( *this )[2][0] * other[0][0] + ( *this )[2][1] * other[1][0] + ( *this )[2][2] * other[2][0] + ( *this )[2][3] * other[3][0];
	result[2][1] = ( *this )[2][0] * other[0][1] + ( *this )[2][1] * other[1][1] + ( *this )[2][2] * other[2][1] + ( *this )[2][3] * other[3][1];
	result[2][2] = ( *this )[2][0] * other[0][2] + ( *this )[2][1] * other[1][2] + ( *this )[2][2] * other[2][2] + ( *this )[2][3] * other[3][2];
	result[2][3] = ( *this )[2][0] * other[0][3] + ( *this )[2][1] * other[1][3] + ( *this )[2][2] * other[2][3] + ( *this )[2][3] * other[3][3];

	result[3][0] = ( *this )[3][0] * other[0][0] + ( *this )[3][1] * other[1][0] + ( *this )[3][2] * other[2][0] + ( *this )[3][3] * other[3][0];
	result[3][1] = ( *this )[3][0] * other[0][1] + ( *this )[3][1] * other[1][1] + ( *this )[3][2] * other[2][1] + ( *this )[3][3] * other[3][1];
	result[3][2] = ( *this )[3][0] * other[0][2] + ( *this )[3][1] * other[1][2] + ( *this )[3][2] * other[2][2] + ( *this )[3][3] * other[3][2];
	result[3][3] = ( *this )[3][0] * other[0][3] + ( *this )[3][1] * other[1][3] + ( *this )[3][2] * other[2][3] + ( *this )[3][3] * other[3][3];

	return result;

	// LAPACK
	/*integer n = 4; // 列のサイズ
	double A[16];
	A[0] = ( *this )[0][0]; A[4] = ( *this )[0][1]; A[8] = ( *this )[0][2]; A[12] = ( *this )[0][3];
	A[1] = ( *this )[1][0]; A[5] = ( *this )[1][1]; A[9] = ( *this )[1][2]; A[13] = ( *this )[1][3];
	A[2] = ( *this )[2][0]; A[6] = ( *this )[2][1]; A[10] = ( *this )[2][2]; A[14] = ( *this )[2][3];
	A[3] = ( *this )[3][0]; A[7] = ( *this )[3][1]; A[11] = ( *this )[3][2]; A[15] = ( *this )[3][3];

	double B[16];
	B[0] = other[0][0]; B[4] = other[0][1]; B[8] = other[0][2]; B[12] = other[0][3];
	B[1] = other[1][0]; B[5] = other[1][1]; B[9] = other[1][2]; B[13] = other[1][3];
	B[2] = other[2][0]; B[6] = other[2][1]; B[10] = other[2][2]; B[14] = other[2][3];
	B[3] = other[3][0]; B[7] = other[3][1]; B[11] = other[3][2]; B[15] = other[3][3];

	double C[16];
	C[0] = 1.0; C[4] = 0.0; C[8] = 0.0; C[12] = 0.0;
	C[1] = 0.0; C[5] = 1.0; C[9] = 0.0; C[13] = 0.0;
	C[2] = 0.0; C[6] = 0.0; C[10] = 1.0; C[14] = 0.0;
	C[3] = 0.0; C[7] = 0.0; C[11] = 0.0; C[15] = 1.0;
	double alpha = 1.0, beta = 0.0;

	dgemm_ ( "n", "n", &n, &n, &n, &alpha, A, &n, B, &n, &beta, C, &n );

	Mat4T<T> result{
		T ( C[0] ), T ( C[4] ), T ( C[8] ),  T ( C[12] ),
		T ( C[1] ), T ( C[5] ), T ( C[9] ),  T ( C[13] ),
		T ( C[2] ), T ( C[6] ), T ( C[10] ), T ( C[14] ),
		T ( C[3] ), T ( C[7] ), T ( C[11] ), T ( C[15] )
	};
	return result;*/
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec4T<T> Mat4T<T>::operator * ( const Vec4T<T> &vec4 ) const {
	return Vec4T<T> {
		( *this )[0][0] * vec4.x + ( *this )[0][1] * vec4.y + ( *this )[0][2] * vec4.z + ( *this )[0][3] * vec4.t,
		( *this )[1][0] * vec4.x + ( *this )[1][1] * vec4.y + ( *this )[1][2] * vec4.z + ( *this )[1][3] * vec4.t,
		( *this )[2][0] * vec4.x + ( *this )[2][1] * vec4.y + ( *this )[2][2] * vec4.z + ( *this )[2][3] * vec4.t,
		( *this )[3][0] * vec4.x + ( *this )[3][1] * vec4.y + ( *this )[3][2] * vec4.z + ( *this )[3][3] * vec4.t
	};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Mat4T<T>::operator * ( const Vec3T<T> &vec3 ) const {
	Vec4T<T> vec4 = *this * Vec4T<T> { vec3.x, vec3.y, vec3.z, T ( 1.0 ) };
	return Vec3T<T> { vec4.x, vec4.y, vec4.z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator * ( T val ) const {
	return Mat4T<T> { this->row[0] * val, this->row[1] * val, this->row[2] * val, this->row[3] * val };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator *= ( const Mat4T &other ) {
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator *= ( T val ) {
	*this = *this * val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> Mat4T<T>::operator / ( T val ) const {
	assert ( Math::IsZero ( val ) == false );
	return *this * ( T ( 1.0 ) / val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Mat4T<T>::operator /= ( T val ) {
	*this = *this / val;
}
