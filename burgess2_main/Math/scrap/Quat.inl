
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT () {
	this->setIdentity ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( T setX, T setY, T setZ, T setW )
	: v { Vec3T<T> { setX, setY, setZ } }
	, w { setW } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const std::vector<T> &arrayVal ) {
	if ( arrayVal.size () < 4 ) {
		this->setIdentity ();
		return;
	}
	this->v = Vec3T<T> { arrayVal [0], arrayVal [1], arrayVal [2] };
	this->w = arrayVal[3];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const VecT<T> &vec ) {
	if ( vec.size () < 4 ) { 
		this->setIdentity ();
		return;
	}
	this->v = Vec3T<T> { vec [0], vec [1], vec [2] };
	this->w = vec [3];
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Vec3T<T> &v, T w ) 
	: v ( v )
	, w ( w ) 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Vec4T<T> &_v ){
	this->v.x = _v.x;
	this->v.y = _v.y;
	this->v.z = _v.z;
	this->w = _v.t;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Deg3T<T> &deg ) {
	this->setFromDeg3 ( deg );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Rad3T<T> &rad ) {
	this->setFromRad3 ( rad );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Mat3T<T> &mat ) {
	this->setFromMat3 ( mat );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const Mat4T<T> &mat ) {
	Mat3T<T> m3 = mat.getMat3 ();
	this->setFromMat3 ( m3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>::QuatT ( const QuatT &other ) : v ( other.v ), w ( other.w ) {}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位ベクトルにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setIdentity () {
	*this = QuatT { Vec3T<T> {T ( 0.0 )}, T ( 1.0 ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     値を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::set ( const Vec3T<T> &v, T w ) {
	*this = QuatT { v, w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromMat3 ( const Mat3T<T> &mat ) {
	T trace = mat.row [0][0] + mat.row [1][1] + mat.row [2][2];

	if ( T ( 0 ) < trace ) {
		T s = T ( 2.0 ) * std::sqrt ( trace  + T ( 1.0 ) );
		assert ( Math::IsZero ( s ) == false );

		this->w = T ( 0.25 ) * s;
		T x = mat [2] [1] - mat [1] [2];
		T y = mat [0] [2] - mat [2] [0];
		T z = mat [1] [0] - mat [0] [1];
		this->v = Vec3T<T> { x, y, z } * T ( 1.0 ) / s;

	} else if ( mat [1] [1] < mat [0] [0] && mat [2] [2] < mat [0] [0] ) {
		T s = T ( 2.0 ) * std::sqrt ( T ( 1.0 ) + mat [0] [0] - mat [1] [1] - mat [2] [2] );
		assert ( Math::IsZero ( s ) == false );

		T invS = T ( 1.0 ) / s;
		this->w = ( mat [2] [1] - mat [1] [2] ) * invS;
		T x = T ( 0.25 ) * s;
		T y = ( mat [0] [1] + mat [1] [0] ) * invS;
		T z = ( mat [0] [2] + mat [2] [0] ) * invS;
		this->v = Vec3T<T> {  x, y, z };

	} else if ( mat [2] [2] < mat [1] [1] ) {
		T s = T ( 2.0 ) * std::sqrt ( T ( 1.0 ) + mat [1] [1] - mat [0] [0] - mat [2] [2] );
		assert ( Math::IsZero ( s ) == false );

		T invS = T ( 1.0 ) / s;
		this->w = ( mat [0] [2] - mat [2] [0] ) * invS;
		T x = ( mat [0] [1] + mat [1] [0] ) * invS;
		T y = T ( 0.25 ) * s;
		T z = ( mat [1] [2] + mat [2] [1] ) * invS;
		this->v = Vec3T<T> { x, y, z };

	} else {
		T s = T ( 2.0 ) * std::sqrt ( T ( 1.0 ) + mat [2] [2] - mat [0] [0] - mat [1] [1] );
		assert ( Math::IsZero ( s ) == false );

		T invS = T ( 1.0 ) / s;
		this->w = ( mat [1][0] - mat [0][1] ) * invS;
		T x = ( mat [0] [2] + mat [2] [0] ) * invS;
		T y = ( mat [1] [2] + mat [2] [1] ) * invS;
		T z = T ( 0.25 ) * s;
		this->v = Vec3T<T> { x, y, z };
	}
	this->setUnit ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      オイラー（ラジアン単位）から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromRad3 ( const Rad3T<T> &rad ) {
	T sx = std::sin ( rad.x * T(0.5) );
	T sy = std::sin ( rad.y * T(0.5) );
	T sz = std::sin ( rad.z * T(0.5) );
	T cx = std::cos ( rad.x * T(0.5) );
	T cy = std::cos ( rad.y * T(0.5) );
	T cz = std::cos ( rad.z * T(0.5) );
	
	switch (rad.rotationOrder) {
	case 0:/// xyz
		this->v.x = sx * cy * cz - cx * sy * sz;
		this->v.y = sx * cy * sz + cx * sy * cz;
		this->v.z = cx * cy * sz - sx * sy * cz;
		this->w = cx * cy * cz + sx * sy * sz;
		break;
	case 1:/// xzy
		this->v.x = sx * cz * cy + cx * sz * sy;
		this->v.y = cx * cz * sy + sx * sz * cy;
		this->v.z = -sx * cz * sy + cx * sz * cy;
		this->w = cx * cz * cy - sx * sz * sy;
		break;
	case 2:/// yzx
		this->v.x = cy * cz * sx - sy * sz * cx;
		this->v.y = sy * cz * cx - cy * sz * sx;
		this->v.z = sy * cz * sx + cy * sz * cx;
		this->w = cy * cz * cx + sy * sz * sx;
		break;
	case 3:/// yxz
		this->v.x = cy * sx * cz - sy * cx * sz;
		this->v.y = cy * sx * sz + sy * cx * cz;
		this->v.z = cy * cx * sz + sy * sx * cz;
		this->w = cy * cx * cz - sy * sx * sz;
		break;
	case 4:/// zxy
		this->v.x = cz * sx * cy + sz * cx * sy;
		this->v.y = cz * cx * sy - sz * sx * cy;
		this->v.z = -cz * sx * sy + sz * cx * cy;
		this->w = cz * cx * cy + sz * sx * sy;
		break;
	case 5:/// zyx
		this->v.x = cz * cy * sx + sz * sy * cx;
		this->v.y = cz * sy * cx - sz * cy * sx;
		this->v.z = cz * sy * sx + sz * cy * cx;
		this->w = cz * cy * cx - sz * sy * sx;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     オイラー（デグリー単位）から回転を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromDeg3 ( const Deg3T<T> &deg ) {
	this->setFromRad3 ( Rad3T<T> { deg } );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     軸と角度（ラジアン単位）で定義される回転に設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromAxisAndAngle ( const Vec3T<T> &axis, T angle ) {
	T halfAngle = angle * T(0.5);
	this->set ( axis.unit () * std::sin ( halfAngle ), std::cos ( halfAngle ) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    方向とアップベクトルから回転を設定する (例：axis=0の場合は direction=Z, upV=Y)
//!		@param[in] type 0=ZY, 1=ZX, 2=XZ, 3=XY, 4=YX, 5=YZ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromDirectionAndUpvector ( const Vec3T<T> &direction, const Vec3T<T> &upvector, u8 type, Bool dirNeg, Bool upVectorNeg ) {
	Mat3T<T> m3;
	m3.setFromDirectionAndUpvector ( direction, upvector, type, dirNeg, upVectorNeg );
	this->setFromMat3 ( m3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     sourcVecからtargetVecまでの回転の差分を取得する (引数はどちらも単位ベクトル)
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFrom2Vectors ( const Vec3T<T> &sourcVec, const Vec3T<T> &targetVec ) {
	T dot = sourcVec.dot ( targetVec ) + 1;
	if ( T ( 0.0 ) < dot ) { dot = std::sqrt ( dot * T ( 2.0 ) ); }
	this->w = dot / T ( 2.0 );
	Vec3T<T> cross = sourcVec.cross ( targetVec );
	this->v = cross / dot;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     対数クォータニオンからクォータニオンを設定する <br>

//!		参照コード提供元　Mukai Laboratory　https://mukai-lab.org/
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setFromExpmap ( const Vec3T<T> &expmap ) {
	T mag = std::sqrt ( expmap[0] * expmap[0] + expmap[1] * expmap[1] + expmap[2] * expmap[2] );
	T sina = std::abs ( mag ) < 1.0e-6 ? 0.0 : std::sin ( mag ) / mag;

	*this = QuatT<T>{
		expmap[0] * sina,
		expmap[1] * sina,
		expmap[2] * sina,
		std::cos ( mag ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     X軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getXaxis () const {
	Vec3T<T> result;
	result.x = T(1.0) - T(2.0) * ( this->v.z * this->v.z + this->v.y * this->v.y );
	result.y = T(2.0) * ( this->v.x * this->v.y + this->v.z * this->w );
	result.z = T(2.0) * ( this->v.x * this->v.z - this->v.y * this->w );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Y軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getYaxis () const {
	Vec3T<T> result;
	result.x = T(2.0) * ( this->v.x * this->v.y - this->v.z * this->w );
	result.y = T(1.0) - T(2.0) * ( this->v.z * this->v.z + this->v.x * this->v.x );
	result.z = T(2.0) * ( this->v.y * this->v.z + this->v.x * this->w );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Z軸を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::getZaxis () const {
	Vec3T<T> result;
	result.x = T(2.0) * ( this->v.y * this->w + this->v.x * this->v.z );
	result.y = T(2.0) * ( this->v.y * this->v.z - this->v.x * this->w );
	result.z = T(1.0) - T(2.0) * ( this->v.y * this->v.y + this->v.x * this->v.x );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     アングル（ラジアン単位）を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::getAngle () const {
	return std::acos ( this->w ) * T(2.0);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecに変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> QuatT<T>::toVec () const {
	return VecT<T> { this->v.x, this->v.y, this->v.z, this->w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> QuatT<T>::toTypeArray () const {
	return std::vector<T> { this->v.x, this->v.y, this->v.z, this->w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> QuatT<T>::toMat3 () const{
	Vec3T<T> row0;
	Vec3T<T> row1;
	Vec3T<T> row2;
	row0.x = T(1.0) - T(2.0) * (this->v.y * this->v.y + this->v.z * this->v.z);
	row1.x = T(2.0) * (this->v.x * this->v.y + this->w * this->v.z);
	row2.x = T(2.0) * (this->v.x * this->v.z - this->w * this->v.y);

	row0.y = T(2.0) * (this->v.x * this->v.y - this->w * this->v.z);
	row1.y = T(1.0) - T(2.0)* (this->v.x * this->v.x + this->v.z * this->v.z);
	row2.y = T(2.0) * (this->v.y * this->v.z + this->w * this->v.x);

	row0.z = T(2.0) * (this->v.x * this->v.z + this->w * this->v.y);
	row1.z = T(2.0) * (this->v.y * this->v.z - this->w * this->v.x);
	row2.z = T(1.0) - T(2.0) * (this->v.x * this->v.x + this->v.y * this->v.y);

	return Mat3T<T> { row0, row1, row2 };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Rad3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T> QuatT<T>::toRad3 ( u8 order ) const {
	Mat3T<T> m3 ( *this );
	return Rad3T<T> ( m3, order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Deg3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T> QuatT<T>::toDeg3 ( u8 order ) const {
	return Deg3T<T> { Rad3T<T> { *this, order } };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String QuatT<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	return t + "Quat:[" + GetFloorString ( this->v.x ) + ", " + GetFloorString ( this->v.y ) + ", " + GetFloorString ( this->v.z ) + ", " + GetFloorString ( this->w ) + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのクォータニオンの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::equal ( const QuatT &other ) const {
	return this->v.equal ( other.v ) && this->w == other.w;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのクォータニオンの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::almostEqual ( const QuatT &other, T precision ) const {
	return	this->v.almostEqual ( other.v, precision ) && Math::AlmostEqual( this->w, other.w, precision );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     クォータニオンの値が全て0の場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::isZero () const {
	return	this->v.isZero() && Math::AlmostEqual ( this->w, T(0.0) );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと線形補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::lerp ( const QuatT &other, T t ) const{
	Vec3T<T> restV = other.v;
	f32 restW = other.w;
	if ( this->dot ( other ) < T(0.0) ) {
		restV.setNegate ();
		restW *= T(-1.0);
	}
	QuatT<T> result { this->v.lerp ( restV, t ),  Math::Lerp ( this->w, restW, t ) };
	return result.unit ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと球状補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>  QuatT<T>::slerp ( const QuatT &other, T t ) const{
	QuatT<T> restQ = other;
	if ( this->dot( other ) < 0.0 ) {
		restQ.v.setNegate ();
		restQ.w *= T ( -1.0 );
	}

	QuatT<T> result = *this;

	T d = this->dot ( restQ );
	if ( std::abs ( d ) < 1.0 ) {
		T ad = std::acos ( d );
		T sd = std::sqrt ( T(1.0) - SQ(d) );

		if ( std::abs ( sd ) < Burgess::DIVTOLERANCE ) {
			result = QuatT<T> ( ( this->v + restQ.v ) * T(0.5), ( this->w + restQ.w ) * T(0.5) );
		} else {
			T s1 = std::sin ( ( 1.0 - t ) * ad ) / sd;
			T s2 = std::sin ( t * ad ) / sd;
			result = QuatT<T> ( this->v * s1 + restQ.v * s2, this->w * s1 + restQ.w * s2 );
		}
	}

	return result.unit ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象クォータニオンと線形補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>  QuatT<T>::linearInterpolate ( const QuatT &other, T t )const {
	return this->lerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      t値(0.0~1.0)に基づいて対象クォータニオンと球状補間したクォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T>  QuatT<T>::sphericalLinearInterpolate ( const QuatT &other, T t ) const{
	return this->slerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     クォータニオンの長さを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::length () const {
	return std::sqrt ( this->lengthSquared () );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2乗を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::lengthSquared () const {
	return this->w * this->w + this->v.lengthSquared ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::dist ( const QuatT &other )const{
	QuatT d = this->conjugate () * (this->dot ( other ) < T ( 0.0 ) ? other * T ( -1.0 ) : other);
	Vec3T<T> rest;
	T angle;
	d.getAxisAndAngle ( rest, angle );
	return std::abs ( angle );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setNormal () {
	T n = this->length ();
	assert ( Math::IsZero ( n ) == false );
	*this = *this / n;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setUnit () {
	this->setNormal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::normal () const {
	T n = this->length ();
	assert ( Math::IsZero ( n ) == false );
	return *this / n;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     単位クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::unit () const {
	return this->normal ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数クォータニオンを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::inverse () const {
	QuatT<T> q = this->normal ();
	return q.conjugate ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     逆数クォータニオンにする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setInverse () {
	*this = this->inverse ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     共役を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::conjugate () const {
	return QuatT { this->v.negate (), this->w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     対数クォータニオンを返す

//!	     参照コード提供元　Mukai Laboratory　https://mukai-lab.org/
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::expmap () const {
	QuatT<T> q = this->w < 0.0 ? *this * -1.0 : *this;
	T isina;
	if ( T ( 1.0 - 1.0e-6) < std::abs(q.w) ) {
		isina = T(0.0);
	} else {
		T a = std::acos ( q.w );
		isina = a / std::sin ( a );
	}
	return q.v * isina;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::getAxisAndAngle ( OUT Vec3T<T> &axis, OUT T &angle ) const {
	QuatT<T> q = *this;
	if ( T ( 1.0 ) < q.w ) {
		q.setNormal ();
	}
	angle = 2.0 * std::acos ( q.w );
	T s = std::sqrt ( 1.0 - q.w * q.w ); 
	if ( s < 0.001 ) {
		axis.x = q.v.x;
		axis.y = q.v.y;
		axis.z = q.v.z;
	} else {
		axis.x = q.v.x / s;
		axis.y = q.v.y / s;
		axis.z = q.v.z / s;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     軸に従って反転したクォータニオンを返す
//!	    @brief	反転面に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸Z, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::mirror ( u32 mirrorNorml ) const {
	QuatT<T> result { *this };
	result.setMirror ( mirrorNorml );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     軸に従って反転したクォータニオンにする
//!	    @brief	反転面に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸Z, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setMirror ( u32 mirrorNorml ) {
	T restW = this->w;
	switch ( mirrorNorml ) {
		case 1: /// y
			this->w = -this->v.x;
			this->v = Vec3T<T> { -restW, this->v.z, this->v.y };
			break;
		case 2: /// z
			this->w = -this->w;
			this->v = Vec3T<T> { this->v.x, this->v.y, -this->v.z };
			break;
		default: /// x
			this->w = this->v.y;
			this->v = Vec3T<T> { this->v.z, restW, this->v.x };
			break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    リグ用：軸に従って反転したクォータニオンを返す
//!	    @brief	反転面に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸Z, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::mirror2 ( u32 mirrorNorml ) const {
	QuatT<T> result { *this };
	result.setMirror2 ( mirrorNorml );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    リグ用：軸に従って反転したクォータニオンにする
//!	    @brief	反転面に従って反転したクォータニオンにする
//!		@param[in] mirrorNorml 反転する軸 0=X軸, 1=Y軸Z, 2=Z軸
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::setMirror2 ( u32 mirrorNorml ) {
	switch ( mirrorNorml ) {
	case 1: /// y
		this->v *= Vec3T<T> ( T ( -1.0 ), T ( 1.0 ), T ( -1.0 ) );
		break;
	case 2: /// z
		this->v *= Vec3T<T> ( T ( -1.0 ), T ( -1.0 ), T ( 1.0 ) );
		break;
	default: /// x
		this->v *= Vec3T<T> ( T ( 1.0 ), T ( -1.0 ), T ( -1.0 ) );
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     内積を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T QuatT<T>::dot ( const QuatT &other ) const {
	return this->w * other.w + this->v.dot ( other.v );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     ベクトルをこのクォータニオンで回転したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> QuatT<T>::rotatVector ( const Vec3T<T> &val ) const {
	QuatT<T> restQuat0 { val.x, val.y, val.z, T(0.0) };
	QuatT<T> restQuat1 { this->v.negate (), this->w };

	QuatT<T> result = *this * restQuat0 * restQuat1;
	return result.v;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::addAngle ( const Deg3T<T> &deg ) const {
	QuatT other{ deg };
	return other * (*this);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::addAngle ( const Rad3T<T> &rad ) const {
	QuatT other{ rad };
	return other * (*this);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x,y,z,wへ[0~3]としてアクセスする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& QuatT<T>::operator[]( u8 id ) {
	assert ( id < 4 );
	switch ( id ) {
	case 0:
		return this->v.x;
		break;
	case 1:
		return this->v.y;
		break;
	case 2:
		return this->v.z;
		break;
	case 3:
		return this->w;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& QuatT<T>::operator[]( u8 id ) const {
	assert ( id < 4 );
	switch ( id ) {
	case 0:
		return this->v.x;
		break;
	case 1:
		return this->v.y;
		break;
	case 2:
		return this->v.z;
		break;
	case 3:
		return this->w;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::operator == ( const QuatT &other ) const {
	return this->v == other.v && this->w == other.w;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool QuatT<T>::operator != ( const QuatT &other ) const {
	return this->v != other.v || this->w != other.w;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator + ( const QuatT &other ) const {
	return QuatT<T> { this->v + other.v, this->w + other.w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator += ( const QuatT &other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator * ( const QuatT &other ) const {
	Vec3T<T> v = this->v.cross ( other.v ) + (other.v * this->w) + (this->v * other.w);
	T w = this->w * other.w - this->v.dot ( other.v );
	return QuatT<T> { v.x, v.y, v.z, w };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator * ( T val ) const {
	return QuatT { this->v * val, this->w * val };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator *= ( const QuatT &other ) {
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator *= ( T val ) {
	*this = *this * val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator / ( const QuatT &other ) const {
	Vec3T<T> resV = ( this->v * other.w ) - ( other.v * this->w ) - this->v.cross ( other.v );
	f32 resW = this->w * other.w + this->v.dot ( other.v );
	return QuatT { resV, resW };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> QuatT<T>::operator / ( T  val ) const {
	assert ( Math::IsZero ( val ) == false );
	return *this * ( 1.0f / val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator /= ( const QuatT &other ) {
	*this = *this / other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void QuatT<T>::operator /= ( T val ) {
	*this = *this / val;
}