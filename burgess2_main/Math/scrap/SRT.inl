
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT () {
	this->setIdentity ();
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Vec3T<T> &_tr )
	: sc { Vec3T<T> { T ( 1.0 ) } }
	, rot { Deg3T<T> {} }
	, tr { _tr } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const QuatT<T> &_rot, u8 order )
	: sc { Vec3T<T> { T ( 1.0 ) } }
	, rot{ Deg3T<T> { _rot, order } }
	, tr { Vec3T<T> { T ( 0.0 ) } } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Deg3T<T> &euler )
	: sc { Vec3T<T> ( T ( 1.0 ) ) }
	, rot { euler }
	, tr { Vec3T<T> ( T ( 0.0 ) ) } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Rad3T<T> &euler )
	: sc { Vec3T<T> ( T ( 1.0 ) ) }
	, rot { Deg3T<T> { euler } }
	, tr { Vec3T<T> ( T ( 0.0 ) ) } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Vec3T<T> &_sc, const QuatT<T> &_rot, const Vec3T<T> &_tr, u8 order )
	: sc { _sc }
	, rot{ Deg3T<T> {_rot, order} }
	, tr { _tr } 
{}


//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Vec3T<T> &_sc, const Deg3T<T> &euler, const Vec3T<T> &_tr) 
	: sc { _sc }
	, rot { euler }
	, tr { _tr }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Vec3T<T> &_sc, const Rad3T<T> &euler, const Vec3T<T> &_tr)
	: sc { _sc }
	, rot { Deg3T<T> { euler } }
	, tr { _tr } 
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Mat4T<T> &mat4, u8 order ) {
	*this = mat4.toSRT (order);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const Mat3T<T> &mat3, u8 order ) {
	this->rot.setFromMat3 (mat3, order);
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T>::SRTT ( const XfoT<T> &xfo, u8 order ){
	this->sc = xfo.sc;
	this->rot( xfo.ori, order );
	this->tr = xfo.tr;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    初期値（ sc= 1,1,1 rot=0,0,0 tr=0,0,0） にする 
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::setIdentity (){
	this->sc = Vec3T<T> { T ( 1.0 ) };
	this->rot = Deg3T<T>{ T ( 0.0 ) };
	this->tr = Vec3T<T> { T ( 0.0 ) };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat4型へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat4T<T> SRTT<T>::toMat4 () const{
	Mat4T<T> sc;
	sc.setDiagonal ( Vec4T<T> { this->sc.x, this->sc.y, this->sc.z, T ( 1.0 ) } );

	Mat3T<T> rotM3 = this->rot.toMat3();
	Mat4T<T> rot { rotM3 };

	Mat4T<T> tr;
	tr.setTranslation ( this->tr );

	return tr * rot * sc;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String SRTT<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }
	String s = "sc Vec3[" + GetFloorString ( this->sc.x ) + ", " + GetFloorString ( this->sc.y ) + ", " + GetFloorString ( this->sc.z ) + "]";
	String r = "rot Deg3["+ GetFloorString ( this->rot.x ) + ", " + GetFloorString ( this->rot.y ) + ", " + GetFloorString ( this->rot.z ) + "]";
	String tt = "tr Vec3[" + GetFloorString ( this->tr.x ) + ", " + GetFloorString ( this->tr.y ) + ", " + GetFloorString ( this->tr.z ) + "]";
	return t + "SRT:[" + s + " / " + r + " / " + tt + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      2つのSRTの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool SRTT<T>::equal ( const SRTT &other ) const{
	return
		this->sc == other.sc &&
		this->rot == other.rot &&
		this->tr == other.tr;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      2つのSRTの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool SRTT<T>::almostEqual ( const SRTT &other, T precision ) const{
	return
		this->sc.almostEqual ( other.sc, precision ) &&
		this->rot.almostEqual ( other.rot, precision ) &&
		this->tr.almostEqual ( other.tr, precision );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      t値(0.0~1.0)に基づいて対象SRTと線形補間したSRTを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> SRTT<T>::lerp ( const SRTT &other, T t ) const {
	SRTT<T> result;
	result.sc = this->sc.linearInterpolate ( other.sc, t );
	result.rot = Deg3T<T>{ QuatT<T>{ this->rot }.linearInterpolate ( QuatT<T>{other.rot}, t ) };
	result.tr = this->tr.linearInterpolate ( other.tr, t );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象SRTと線形補間したSRTを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> SRTT<T>::linearInterpolate ( const SRTT &other, T t ) const {
	return this->lerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     t値(0.0~1.0)に基づいて対象SRTと回転を球状補間、位置とスケールを線形補間したSRTを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> SRTT<T>::slerp ( const SRTT &other, T t ) const {
	SRTT<T> result;
	result.sc = this->sc.lerp ( other.sc, t );
	result.rot = Deg3T<T>{ QuatT<T>{ this->rot }.slerp ( QuatT<T>{other.rot}, t ) };
	result.tr = this->tr.lerp ( other.tr, t );
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	       t値(0.0~1.0)に基づいて対象SRTと回転を球状補間、位置とスケールを線形補間したSRTを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> SRTT<T>::sphericalLinearInterpolate ( const SRTT &other, T t ) const {
	return this->slerp ( other, t );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     移動値を加算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::addTr ( const Vec3T<T> &val ){
	this->tr += val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値(Quat)を加算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::addRot ( const QuatT<T> &val, u8 order ) {
	this->rot = Deg3T<T>{ QuatT<T>{this->rot} +val, order };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値(Deg3)を加算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::addRot ( const Deg3T<T> &val ) {
	this->rot += val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     回転値(Rad3)を加算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::addRot ( const Rad3T<T> &val ) {
	this->rot += val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     スケール値を加算する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::addSc ( const Vec3T<T> &val ) {
	this->sc += val;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     SRTでトランスフォームしたベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> SRTT<T>::transformVector ( const Vec3T<T> &val ) const{
	return this->rot.rotatVector(val * this->sc) + this->tr;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool SRTT<T>::operator == ( const SRTT &other ) const {
	return
		this->sc == other.sc &&
		this->rot == other.rot &&
		this->tr == other.tr;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool SRTT<T>::operator != ( const SRTT &other ) const {
	return
		this->sc != other.sc ||
		this->rot != other.rot ||
		this->tr != other.tr;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
SRTT<T> SRTT<T>::operator * ( const SRTT &other ) const {
	QuatT<T> thisRot = this->rot.unit ();
	SRTT<T> result;
	result.tr = this->tr + thisRot.rotatVector ( other.tr * this->sc );
	result.rot = Deg3T<T>{ ( thisRot *  other.rot.unit () ).unit () };
	result.sc = this->sc * other.sc;
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void SRTT<T>::operator *= ( const SRTT &other ) {
	*this = *this * other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> SRTT<T>::operator * ( const Vec3T<T> &vec ) const {
	return  this->rot.rotatVector ( vec *  this->sc ) + this->tr;
}