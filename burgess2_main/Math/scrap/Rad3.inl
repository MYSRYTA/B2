
//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デフォルトコンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T () 
	: x { 0 }
	, y { 0 }
	, z { 0 } 
	, rotationOrder { 0 }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( T setX, T setY, T setZ, u8 order ) 
	: x { setX }
	, y { setY }
	, z { setZ } 
	, rotationOrder { order }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const Deg3T<T> &deg )
	: x { Math::DegToRad ( deg.x )}
	, y { Math::DegToRad ( deg.y )}
	, z { Math::DegToRad ( deg.z )}
	, rotationOrder { deg.rotationOrder }
{}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const QuatT<T> &quat, u8 order ) {
	*this = quat.toRad3 ( order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const Mat3T<T> &mat3, u8 order ) {
	this->setFromMat3 ( mat3, order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const Mat4T<T> &mat4, u8 order ) {
	Mat3T<T> m3 = mat4.getMat3 ();
	this->setFromMat3 ( m3, order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const VecT<T> &vec, u8 order ) {
	assert ( 3 <= vec.size () );
	*this = { vec [0], vec [1], vec [2], order };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const Vec3T<T> &vec, u8 order ){
	*this = { vec[0], vec[1], vec[2], order };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const Vec4T<T> &vec, u8 order ){
	*this = QuatT<T>( vec ).toRad3 ( order );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     コンストラクタ
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T>::Rad3T ( const std::vector<T> &arrayVal, u8 order ) {
	assert ( 3 <= arrayVal.size () );
	*this = { arrayVal [0], arrayVal [1], arrayVal [2], order };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Vecへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
VecT<T> Rad3T<T>::toVec ()const {
	return VecT<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Typeの配列へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
std::vector<T> Rad3T<T>::toTypeArray () const {
	return std::vector<T> { this->x, this->y, this->z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Deg3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Deg3T<T> Rad3T<T>::toDeg3 () const {
	return Deg3T<T> { T ( Math::RadToDeg ( this->x )), T ( Math::RadToDeg ( this->y )), T ( Math::RadToDeg ( this->z )), this->rotationOrder };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Quatへ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
QuatT<T> Rad3T<T>::toQuat () const {
	return QuatT<T> { *this };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3へ変換する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Mat3T<T> Rad3T<T>::toMat3 () const {
	QuatT<T> q ( *this );
	return q.toMat3( );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     デバッグ用の文字列にする　"データ型：[ 値 ]"
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
String Rad3T<T>::toString ( const String title ) const {
	String t = title;
	if ( title.length () != 0 ) { t += " : ";  }
	String order = std::to_string ( this->rotationOrder );
	switch ( this->rotationOrder ) {
	case 0:
		order += "[XYZ]";
		break;
	case 1:
		order += "[XZY]";
		break;
	case 2:
		order += "[YXZ]";
		break;
	case 3:
		order += "[YZX]";
		break;
	case 4:
		order += "[ZYX]";
		break;
	case 5:
		order += "[ZXY]";
		break;
	default:
		order += "[XYZ]";
	}
	return t + "Rad3:[" + GetFloorString ( this->x ) + ", " + GetFloorString ( this->y ) + ", " + GetFloorString ( this->z ) + ", rotationOrder : " + order + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのラジアン単位オイラーの値が全く同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Rad3T<T>::equal ( const Rad3T &other ) const{
	return this->x == other.x && this->y == other.y && this->z == other.z && this->rotationOrder == other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     2つのラジアン単位オイラーの値が誤差範囲内で同じ場合はtrueを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Rad3T<T>::almostEqual ( const Rad3T &other, T tolerance ) const{
	return
		Math::AlmostEqual ( this->x, other.x, tolerance ) &&
		Math::AlmostEqual ( this->y, other.y, tolerance ) &&
		Math::AlmostEqual ( this->z, other.z, tolerance ) &&
		this->rotationOrder == other.rotationOrder ;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     Mat3からRad3を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Rad3T<T>::setFromMat3 ( const Mat3T<T> &mat3, u8 order ){		
	switch ( order ) {
	case 0: /// XYZ
		this->y = std::asin ( -Math::Clamp ( mat3[2] [0], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[2] [0] ) < Burgess::TOLERANCE0999 ) {
			this->x = std::atan2 ( mat3[2] [1], mat3[2] [2] );
			this->z = std::atan2 ( mat3[1] [0], mat3[0] [0] );
		} else {
			this->x = T ( 0.0 );
			this->z = std::atan2 ( -mat3[0] [1], mat3[1] [1] );
		}
		break;

	case 1:/// XZY
		this->z = std::asin ( Math::Clamp ( mat3[1] [0], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[1] [0] ) < Burgess::TOLERANCE0999 ) {
			this->x = std::atan2 ( -mat3[1] [2], mat3[1] [1] );
			this->y = std::atan2 ( -mat3[2] [0], mat3[0] [0] );
		} else {
			this->x = T ( 0.0 );
			this->y = std::atan2 ( mat3[0] [2], mat3[2] [2] );
		}
		break;

	case 2: /// YZX
		this->z = std::asin ( -Math::Clamp ( mat3[0] [1], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[0] [1] ) < Burgess::TOLERANCE0999 ) {
			this->x = std::atan2 ( mat3[2] [1], mat3[1] [1] );
			this->y = std::atan2 ( mat3[0] [2], mat3[0] [0] );
		} else {
			this->x = std::atan2 ( -mat3[1] [2], mat3[2] [2] );
			this->y = T ( 0.0 );
		}
		break;

	case 3: /// YXZ
		this->x = std::asin ( Math::Clamp ( mat3[2] [1], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[2] [1] ) < Burgess::TOLERANCE0999 ) {
			this->y = std::atan2 ( -mat3[2] [0], mat3[2] [2] );
			this->z = std::atan2 ( -mat3[0] [1], mat3[1] [1] );
		} else {
			this->y = 0;
			this->z = std::atan2 ( mat3[1] [0], mat3[0] [0] );
		}
		break;

	case 4: /// ZXY
		this->x = std::asin ( -Math::Clamp ( mat3[1] [2], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[1] [2] ) <  Burgess::TOLERANCE0999 ) {
			this->y = std::atan2 ( mat3[0] [2], mat3[2] [2] );
			this->z = std::atan2 ( mat3[1] [0], mat3[1] [1] );
		} else {
			this->y = std::atan2 ( -mat3[2] [0], mat3[0] [0] );
			this->z = T ( 0.0 );
		}
		break;

	case 5: /// ZYX
		this->y = std::asin ( Math::Clamp ( mat3[0] [2], T ( -1.0 ), T ( 1.0 ) ) );
		if ( std::abs ( mat3[0] [2] ) < Burgess::TOLERANCE0999 ) {
			this->x = std::atan2 ( -mat3[1] [2], mat3[2] [2] );
			this->z = std::atan2 ( -mat3[0] [1], mat3[0] [0] );
		} else {
			this->x = std::atan2 ( mat3[2] [1], mat3[1] [1] );
			this->z = T ( 0.0 );
		}
		break;
	}
	this->rotationOrder = order;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      自身の回転値を適応したベクトルを返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Vec3T<T> Rad3T<T>::rotatVector ( const Vec3T<T> &vec3 )const {
	QuatT<T> quat ( *this );
	return quat.rotatVector ( vec3 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     .x,y,zへ[0~2]としてアクセスする
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
T& Rad3T<T>::operator[]( u8 id ) {
	assert ( id < 3 );
	switch ( id ) {
	case 0:
		return this->x;
		break;
	case 1:
		return this->y;
		break;
	case 2:
		return this->z;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
const T& Rad3T<T>::operator[]( u8 id ) const {
	assert ( id < 3 );
	switch ( id ) {
	case 0:
		return this->x;
		break;
	case 1:
		return this->y;
		break;
	case 2:
		return this->z;
		break;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Rad3T<T>::operator == ( const Rad3T &other ) const{
	return this->x == other.x && this->y == other.y && this->z == other.z && this->rotationOrder == other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Bool Rad3T<T>::operator != ( const Rad3T &other ) const {
	return this->x != other.x || this->y != other.y || this->z != other.z || this->rotationOrder != other.rotationOrder;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T> Rad3T<T>::operator + ( const Rad3T &other )const {
	assert ( this->rotationOrder == other.rotationOrder );
	return Rad3T<T> { this->x + other.x, this->y + other.y, this->z + other.z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Rad3T<T>::operator += ( const Rad3T &other ) {
	*this = *this + other;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
Rad3T<T> Rad3T<T>::operator - ( const Rad3T &other ) const {
	assert ( this->rotationOrder == other.rotationOrder );
	return Rad3T<T> { this->x - other.x, this->y - other.y, this->z - other.z };
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
void Rad3T<T>::operator -= ( const Rad3T &other ) {
	*this = *this - other;
}