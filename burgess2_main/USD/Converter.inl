//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<typename T>
void Convert ( OUT Mat4T<T>& brg, const GfMatrix4d& usd ) {
	GfVec4d v0 = usdMat4.GetColumn ( 0 );
	GfVec4d v1 = usdMat4.GetColumn ( 1 );
	GfVec4d v2 = usdMat4.GetColumn ( 2 );
	GfVec4d v3 = usdMat4.GetColumn ( 3 );
	brg = Mat4T<T>{
		Vec4T<T> ( T(v0[0]), T(v0[1]), T(v0[2]), T(v0[3]) ),
		Vec4T<T> ( T(v1[0]), T(v1[1]), T(v1[2]), T(v1[3]) ),
		Vec4T<T> ( T(v2[0]), T(v2[1]), T(v2[2]), T(v2[3]) ),
		Vec4T<T> ( T(v3[0]), T(v3[1]), T(v3[2]), T(v3[3]) ),
	};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<typename T>
void Convert ( OUT std::vector<Mat4T<T>>& brg, const VtArray<GfMatrix4d>& usd ) {
	s32 cnt = usd.size ();
	brg.resize ( cnt );
	#pragma omp parallel for if ( 300 < cnt )
	for ( s32 i = 0; i < cnt; i++ ) {
		Convert ( brg[i], usd[i] );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<typename T>
void Convert ( OUT GfMatrix4d& usd, const Mat4T<T>& brg ) {
	Vec4T<T> v0 = brg.getColValues ( 0 );
	Vec4T<T> v1 = brg.getColValues ( 1 );
	Vec4T<T> v2 = brg.getColValues ( 2 );
	Vec4T<T> v3 = brg.getColValues ( 3 );
	usd = GfMatrix4d{
		f64 ( v0[0] ), f64 ( v0[1] ), f64 ( v0[2] ), f64 ( v0[3] ),
		f64 ( v1[0] ), f64 ( v1[1] ), f64 ( v1[2] ), f64 ( v1[3] ),
		f64 ( v2[0] ), f64 ( v2[1] ), f64 ( v2[2] ), f64 ( v2[3] ),
		f64 ( v3[0] ), f64 ( v3[1] ), f64 ( v3[2] ), f64 ( v3[3] ),
	};
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<typename T>
void Convert ( OUT VtArray<GfMatrix4d>& usd, const std::vector<Mat4T<T>>& brg ) {
	s32 cnt = brg.size ();
	usd.resize ( cnt );
	#pragma omp parallel for if ( 300 < cnt )
	for ( s32 i = 0; i < cnt; i++ ) {
		Convert ( usd[i], brg[i] );
	}
}