//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
LArrayT<N, T>::LArrayT () {
	this->resize ( 0 );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
LArrayT<N, T>::LArrayT ( u32 size ) {
	this->resize ( size );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
LArrayT<N, T>::LArrayT ( const LArrayT<N, T> &other ) {
	if ( this->classLength () != other.classLength () ) { return; }

	this->resize( other.size() );
	for ( u32 i = 0; i<other.size (); i++ ) {
		this->setValue ( i, other.getValue ( i ) );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
LArrayT<N, T>::LArrayT ( const std::vector<T> &val ) {
	this->resize ( val.size () );
	for ( u32 i = 0, n = val.size(); i<n; ++i ) {
		this->setValue ( i, val[ i ] );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列数(固定長と可変長配列の合計)を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::resize ( u32 size ) {
	u32 s = Burgess2MathFn::Max ( u32(this->classLength ()), size );
	this->others.resize ( s - this->classLength () );
	this->count = size;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     可変長配列を解放する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::clearOtherArray () {
	this->others.resize ( 0 );
	this->others.shrink_to_fit ();
	if ( this->classLength () < this->count ) {
		this->count = this->classLength ();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列要素を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::setValue ( u32 _index, T value ) {
	assert ( _index < this->count );
	if ( _index < this->classLength () ) {
		this->val [_index] = value;
	} else {
		this->others [_index - this->classLength ()] = value;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列要素を設定する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::setValues ( const std::vector<T>& val ) {
	this->resize ( val.size () );
	for (u32 i = 0, n = val.size (); i < n; ++i) {
		this->setValue ( i, val[i] );
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      配列の最後に要素を追加する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::push ( T value ) {
	if ( this->count < this->classLength () ) {
		this->val [this->count] = value;
	} else {
		this->others.push_back ( value );
	}
	this->count++;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	      配列の最後に要素を追加する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::push_back ( T value ) {
	this->push ( value );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
T LArrayT<N, T>::getValue ( u32 index )const {
	assert ( index < this->count );
	if ( index < this->classLength () ) {
		return this->val [index];
	} else {
		return this->others [index - this->classLength ()];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
std::vector<T> LArrayT<N, T>::getValues ()const {
	std::vector<T> result ( this->size () );
	u32 n = this->classLength ();
	for ( u32 i = 0; i < n; i++ ) {
		result[i] = this->val[i];
	}
	for ( u32 i = n; i < this->size (); i++ ) {
		result[i] = this->others[i-n];
	}
	return result;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     配列の最後の要素を取得する
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
T LArrayT<N, T>::back ()const {
	u32 s = this->count;
	assert ( 0 < s );
	if ( s <= this->classLength () ) {
		return this->val[s-1];
	} else {
		return this->others[s - this->classLength ()];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     固定長配列の数を返す
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
u8 LArrayT<N, T>::classLength ()const {
	return sizeof ( this->val ) / sizeof ( *this->val );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     有効な配列要素の数を返す(戻り値が固定長の数より少ない場合もある)
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
u32 LArrayT<N, T>::size ()const {
	return this->count;
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    配列を昇順(降順)でソートする (データタイプが単数の場合にのみ有効)
//!		@param[out] arrayOrigID ソート前の配列番号
//!		@param[in] descendingOrder true=降順
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::sort ( OUT std::vector<u32> &arrayOrigID, Bool descendingOrder ) {
	if ( this->size () == 0 ) { return; }
	String type = typeid( T ).name ();
	if ( type != "char" && type != "short" && type != "int" && type != "long" 
		&& type != "unsigned char" && type != "unsigned short" && type != "unsigned int" && type != "unsigned long" 
		&& type != "float" && type != "double" && type != "bool" ) {
		return;
	}

	arrayOrigID.resize ( this->size () );
	for ( u32 i = 0; i< this->size (); i++ ) {
		arrayOrigID [i] = i;
	}
	T restT;
	u32 restU32;
	for ( u32 i = 0; i<this->size (); i++ ) {
		for ( u32 j = i + 1; j<this->size (); j++ ) {
			T iVal = this->getValue ( i );
			T jVal = this->getValue ( j );
			if ( !descendingOrder && jVal < iVal || descendingOrder && iVal < jVal ) {
				restT = iVal;
				this->setValue ( i, jVal );
				this->setValue ( j, restT );

				restU32 = arrayOrigID [i];
				arrayOrigID [i] = arrayOrigID [j];
				arrayOrigID [j] = restU32;
			}
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	    配列を昇順(降順)でソートする (データタイプが単数の場合にのみ有効)
//!		@param[in] descendingOrder true=降順
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
void LArrayT<N, T>::sort ( Bool descendingOrder ) {
	std::vector<u32> dummy;
	this->sort (dummy, descendingOrder );
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
String LArrayT<N, T>::toString ( const String title )const {
	String t = title;
	if ( title.length () != 0 ) { t += " : "; }

	String type = typeid( T ).name ();
	String val = "val:[";
	if ( type == "char" || type == "short" || type == "int" || type == "long"
		|| type == "unsigned char" || type == "unsigned short" || type == "unsigned int" || type == "unsigned long"
		|| type == "float" || type == "double" || type == "bool" ) {
		val += type;
		for ( u32 i = 0; i<this->size (); i++ ) {
			val += ",";
			val += std::to_string ( this->getValue(i) );
		}
	} else {
		for ( u32 i = 0; i<this->size (); i++ ) {
			T val = this->getValue ( i );
			//val += val.toString ();
		}
	}

	return t + "LArrayT:[" + "local classLength="+ std::to_string ( this->classLength() ) + ":count=" + std::to_string ( this->size() )+ ":" + val + "]";
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
T& LArrayT<N, T>::operator[]( u32 id ) {
	assert ( id < this->count );
	if ( id < this->classLength () ) {
		return this->val [id];
	} else {
		return this->others [id - this->classLength ()];
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------
//!	     
//------------------------------------------------------------------------------------------------------------------------------------------------
template<u8 N, typename T>
const T& LArrayT<N, T>::operator[]( u32 id ) const{
	assert ( id < this->count );
	if ( id < this->classLength () ) {
		return this->val [id];
	} else {
		return this->others [id - this->classLength ()];
	}
}